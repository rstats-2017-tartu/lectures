[
["index.html", "Reprodutseeritav andmeanalüüs kasutades R keelt Haara kannel, Vanemuine!", " Reprodutseeritav andmeanalüüs kasutades R keelt Taavi Päll, Ülo Maiväli 2017-09-19 Haara kannel, Vanemuine! Bayesi tõlgenduses on tõenäosus teadlase usu määr mingi hüpoteesi kehtimisse. Hüpotees võib näiteks olla, et järgmise juulikuu sademete hulk Vilsandil jääb vahemikku 22 kuni 34 mm. Kui Bayesi arvutus annab selle hüpoteesi tõenäosuseks 0.57, siis oleme me selle teadmise najal nõus maksma mitte rohkem kui 57 senti kihlveo eest, mille alusel makstakse juhul, kui see hüpotees tõeseks osutub, välja 1 euro (ja me saame vähemalt 43 senti kasumit). "],
["intro.html", "1 Sissejuhatus", " 1 Sissejuhatus See õpik on kirjutatud inimestele, kes kasutavad, mitte ei uuri, statistikat. Õpiku kasutaja peaks olema võimeline töötama R keskkonnas. Meie lähenemised statistika õpetamisele on arvutuslikud, mis tähendab, et me eelistame meetodi matemaatilise aluse asemel õpetada selle kasutamist ja tulemuste tõlgendamist. See õpik on bayesiaanlik ja ei õpeta sageduslikku statistikat. Me usume, et nii on lihtsam ja tulusam statistikat õppida ja et Bayesi statistikat kasutades saab rahuldada 99% teie tegelikest statistilistest vajadustest paremini, kui see on võimalik klassikaliste sageduslike meetoditega. Me usume ka, et kuigi praegused kiired arengud bayesi statistikas on tänaseks juba viinud selle suurel määral tavakasutajale kättesaadavasse vormi, toovad lähiaastad selles vallas veel suuri muutusi. Nende muutustega koos peab arenema ka bayesi õpetamine. Me kasutame järgmisi R-i pakette, mis on kõik loodud bayesi mudelite rakendamise lihtsustamiseks: “rethinking” (McElreath 2016), “brms” (Bürkner 2017), “rstanarm” (Stan Development Team 2016), “BayesianFirstAid” (Bååth 2013) ja “bayesplot” (Gabry and Mahr 2017). Lisaks veel “bayesboot” bootstrapimiseks (Bååth 2016). Bayesi arvutusteks kasutavad need paketid Stan ja JAGS mcmc sämplereid (viimast küll ainult `BayesianFirstAid paket). Selle õpiku valmimisel on kasutatud McElreathi (McElreath 2015), Kruschke (Kruschke 2015) ja nn. Gelmani (Gelman et al. 2014) õpikuid. Lugejad, kellele on juba õpetatud sageduslikku statistikat, võivad tahta teada, mille poolest see erineb bayesi statistikast. Ehkki me usume, et bayesi statistika õpetamine võrdlevalt sagedusliku statistikaga ei ole parim lahendus, võrdleme lühidalt järgnevalt sageduslikku ja bayesi paradigmasid. Kes ei ole õppinud sageduslikku statistikat, võiksid selle osa vahele jätta. Bibliograafia "],
["tools.html", "2 Tarkvaratööriistad 2.1 Installeeri vajalikud programmid 2.2 Loo GitHubi konto 2.3 Loo uus R projekt 2.4 Git Merge konfliktid 2.5 R projekti kataloogi soovitatav minimaalne struktuur 2.6 Pakettide installeerimine 2.7 R repositooriumid", " 2 Tarkvaratööriistad 2.1 Installeeri vajalikud programmid Praktiline kursus eeldab töötavate R, RStudio ja Git programmide olemasolu sinu arvutist. Kõik on väga lihtsad installid. Googelda “install R” või mine otse R allalaadimise veebilehele, laadi alla ja installi sobiv versioon. Googelda “install RStudio” või mine otse RStudio allalaadimise veebilehele, laadi alla ja installi sobiv versioon. Googelda “install git” või mine otse Git allalaadimise veebilehele, laadi alla ja installi sobiv versioon. 2.2 Loo GitHubi konto GitHub on veebipõhine versioonikontrolli repositoorium ja veebimajutuse teenus. konto loomiseks mine lehele https://github.com. Loo endale oma nimega seotud avalik konto. Tulevikule mõeldes vali kasutajanimi hoolikalt. Ära muretse detailide pärast, need on võimalik täita hiljem. Loo repo nimega intro_demo. Lisa repole lühike ja informatiivne kirjeldus. Vali “Public”. Pane linnuke kasti “Initialize this repository with a README”. Klikka “Create Repository”. 2.3 Loo uus R projekt NB! Loo kataloogide nimed ilma tühikuteta. Tühikute asemel kasuta alakriipsu “_”. Ava RStudio (R ise töötab taustal ja sa ei pea seda kunagi ise avama) Ava RStudio akna (Joonis 2.1) paremalt ülevalt nurgast “Project” menüüst “New Project” dialoog. Ava “New Directory” &gt; “Empty Project” &gt; vali projekti_nimi ja oma failisüsteemi alamkataloog kus see projekti kataloog asuma hakkab. Meie kursusel pane projekti/kataloogi nimeks “rstats2017”. Joonis 2.1: RStudio konsoolis on neli akent. Üleval vasakul on sinu poolt nimega varustatud koodi ja teksti editor kuhu kirjutad R skripti. Sinna kirjutad oma koodi ja kommentaarid sellele. All vasakul on konsool. Sinna sisestatakse käivitamisel sinu R kood ja sinna trükitakse väljund. Üleval paremal on Environment aken olulise sakiga . Seal on näha R-i objektid, mis on sulle töökeskkonnas kättesaadavad ja millega sa saad töötada. menüüs on võimalik muutusi vaadata ja ’commit’ida ja -ga suhelda. All paremal on paneel mitme sakiga. Files tab töötab nagu failihaldur. Kui sa lood või avad R projekti, siis näidatakse seal vaikimisi sinu töökataloogi. Kui kasutad R projekti, siis ei ole vaja töökataloogi eraldi seadistada. Plots paneelile ilmuvad joonised, mille sa teed. Packages näitab sulle sinu arvutis olevaid R-i pakette ehk raamatukogusid. Help paneeli avanevad help failid (ka need, mida konsooli kaudu otsitakse). Rohkem infot R projekti loomise kohta leiad RStudio infoleheküljelt: Using Projects. 2.4 Git Merge konfliktid Kollaboreerides üle GitHubi tekivad varem või hiljem konfliktid projekti failide versioonide vahel nn. “merge conflicts”, nende korrektselt lahendama õppimine on väga oluline. Oma repo GitHubi veebilehel muuda/paranda README.md dokumenti ja “Commit”-i seda lühisõnumiga mis sa muutsid/parandasid. Seejärel, muuda oma arvutis olevat README.md faili RStudio-s viies sinna sisse mingi teistsuguse muudatuse. Tee “Commit” oma muudatustele. Proovi “push”-ida – sa saad veateate! Proovi “pull”. Lahenda “merge” konflikt ja seejärel “commit” + “push”. Githubi veateadete lugemine ja Google otsing aitavad sind. 2.5 R projekti kataloogi soovitatav minimaalne struktuur Iga R projekt peab olema täiesti iseseisev (selfcontained) ja sisaldama kogu infot, andmeid ja instruktsioone, et projektiga seotud arvutused läbi viia ja raport genereerida. Kõik faili path-id peavad olema suhtelised. R projekti kataloog peaks sisaldama projekti kirjeldavaid faile, mis nimetatakse DESCRIPTION ja README.md. DESCRIPTION on tavaline tekstifail ja sisaldab projekti metainfot ja infot projekti sõltuvuste kohta, nagu väliste andmesettide asukoht, vajalik tarkvara jne. README.md on markdown formaadis projekti info, sisaldab juhendeid kasutajatele. Igale GitHubi repole on soovitav koostada README.md, esialgu kasvõi projekti pealkiri ja üks kirjeldav lause. README.md ja DESCRIPTION asuvad projekti juurkataloogis. Projekti juurkataloogi jäävad ka kõik .Rmd laiendiga teksti ja analüüsi tulemusi sisaldavad failid, millest genereeritakse lõplik raport/dokument. Suuremad projektid, nagu näiteks teadusartikkel või raamat, võivad sisaldada mitmeid Rmd faile ja võib tekkida kange kisatus need mõnda alamkataloogi tõsta. Aga knitr::knit(), mis Rmarkdowni markdowniks konverteerib, arvestab, et Rmd fail asub juurkataloogis ja arvestab juurkataloogi suhtes ka failis olevaid path-e teistele failidele (näiteks “data/my_data.csv”). data/ kataloog sisaldab faile toorandmetega. Need failid peavad olema R-i poolt loetavad ja soovitavalt tekstipõhised, laienditega TXT, CSV, TSV jne. Neid faile ei muudeta, ainult loetakse. Kogu algandmete töötlus toimub programmaatiliselt. Suured failid muudavad versioonikontrolli aeglaseks, samuti on suheliselt mõttetu versioonikontroll binaarsete failide korral (MS näiteks), sest diffid pole lihtsalt inimkeeles. Github ütleb suurte failide kohta nii: “GitHub will warn you when pushing files larger than 50 MB. You will not be allowed to push files larger than 100 MB.” src/ kataloog sisaldab analüüsi skripte, sealhulgas ka andmetöötluse skripte. lib/ kataloogis on kasutaja poolt tehtud funktsioonide definitsioone sisaldavad R skriptid. project/ |- DESCRIPTION # project metadata and dependencies |- README.md # description of contents and guide to users |- my_analysis.Rmd # markdown file containing analysis | # writeup together with R code chunks | |- data/ # raw data, not changed once created | +-my_data.csv # data files in open formats, | # such as TXT, CSV, TSV etc. | |- src/ # any programmatic code | +-my_scripts.R # R code used to analyse and | # visualise data | |- lib/ # user generated functions | +-my_functions.R # R code defining functions On ka teisi konventsioone, näiteks R pakkide puhul paigutatakse kõik R skriptid taaskasutatavate funktsioonidega kataloogi R/. Kui selles kataloogis olevad skriptid on annoteeritud kasutades Roxygen-i (Wickham, Danenberg, and Eugster 2017), siis genereeritakse automaatselt funktsioonide dokumentatsioon kataloogi man/. Rohkem projekti pakkimise kohta loe värskest preprindist “Packaging data analytical work reproducibly using R” (Marwick, Boettiger, and Mullen 2017). 2.6 Pakettide installeerimine R library-d ehk paketid sisaldavad ühte või enamat mingit kindlat operatsiooni läbi viivat funktsiooni. R baaspakett sisaldab juba mitmeid funktsioone. Kõige esimene sõnum sum() help lehel on “sum {base}”, mis tähendab, et see funktsioon kuulub nn. baasfunktsioonide hulka. Need funktsioonid on alati kättesaadavad sest neid sisaldavad raamatukogud laetakse vaikimisi teie töökeskkonda. Näiteks “base” raamatukogu versioon 3.4.1 sisaldab 453 funktsiooni. Enamasti on sarnaseid asju tegevad funktsioonid koondatud kokku raamatukogudesse ehk pakettidesse, mis tuleb eraldi R kesksest repositooriumist CRAN alla laadida ja installeerida. Selleks, et installeerida pakett, sisesta järgnev käsurida R konsooli: ## eg use &quot;ggplot2&quot; as packagename install.packages(&quot;packagename&quot;) NB! Kui mõni raamatukogu sel viisil alla ei tule, siis guugeldage selle nime + R ja vaadake instruktsioone installeerimiseks. Suure tõenäosusega on tegemist mõnes teises repos (näiteks Bioconductor) või ainult GitHubis asuva paketiga. RStudio võimaldab ka point-and-click stiilis pakettide installeerimist: Joonis 2.2: RStudio ‘Install Packages’ dialoogiaken. Sa ei saa installeeritud pakette enne kasutada, kui laadid nad töökeskkonda kasutades library() funktsiooni. Peale installeerimist lae pakett oma R sessiooni kasutades library() käsku, näiteks: ## Load library/package tidyr library(dplyr) library(dplyr) käsk teeb R sessioonis kasutatavaks kõik “dplyr” paketi funktsioonid. Näiteks “dplyr” pakett sisaldab 237 funktsiooni: library(dplyr) ## let&#39;s look at the head of package list head(ls(&quot;package:dplyr&quot;), 20) ## [1] &quot;%&gt;%&quot; &quot;add_count&quot; &quot;add_count_&quot; ## [4] &quot;add_row&quot; &quot;add_rownames&quot; &quot;add_tally&quot; ## [7] &quot;add_tally_&quot; &quot;all_equal&quot; &quot;all_vars&quot; ## [10] &quot;anti_join&quot; &quot;any_vars&quot; &quot;arrange&quot; ## [13] &quot;arrange_&quot; &quot;arrange_all&quot; &quot;arrange_at&quot; ## [16] &quot;arrange_if&quot; &quot;as_data_frame&quot; &quot;as_tibble&quot; ## [19] &quot;as.tbl&quot; &quot;as.tbl_cube&quot; Konfliktide korral eri pakettide sama nimega funktsioonide vahel saab :: operaatorit kasutades kutsuda välja/importida funktsiooni spetsiifilisest paketist: dplyr::select(df, my_var) Sellisel kujul funktsioonide kasutamisel pole vaja imporditavat funktsiooni sisaldavat raamatukogu töökeskkonda laadida. Funktsioonide-pakettide help failid RStudio kasutajaliidesest: Kui te lähete RStudios paremal all olevale “Packages” tabile, siis on võimalik klikkida raamatukogu nimele ja näha selle help-faile, tutooriale ja kõiki selle raamatukogu funktsioone koos nende help failidega. 2.7 R repositooriumid R pakid on saadaval kolmest põhilisest repositooriumist: CRAN https://cran.r-project.org install.packages(&quot;ggplot2&quot;) Bioconductor https://www.bioconductor.org # First run biocLite script fron bioconductor.org source(&quot;https://bioconductor.org/biocLite.R&quot;) # use &#39;http&#39; in url if &#39;https&#39; is unavailable. biocLite(&quot;GenomicRanges&quot;, suppressUpdates = TRUE) GitHub https://github.com ## Näiteks järgnev käsk installeerib xaringan ## presentation ninja paketi devtools::install_github(&quot;yihui/xaringan&quot;) NB! antud praktilise kursuse raames tutvume ja kasutame ‘tidyverse’ metapaketi funktsioone, laadides need iga sessiooni alguses: ## install.packages(&quot;tidyverse&quot;) library(tidyverse) Nüüd on teil tidyverse pakett arvutis. Tegelikult kuuluvad siia raamatukokku omakorda tosinkond raamatukogu — tidyverse on pisut meta. Igal juhul muutuvad selle funktsioonid kättesaadavaks peale seda, kui te need töökeskkonda sisse loete Veel üks tehniline detail. library(tidyverse) käsk ei loe sisse kõiki alam-raamatukogusid, mis selle nime all CRAN-ist alla laaditi. Need tuleb vajadusel eraldi ükshaaval sisse lugeda. Paiguta kõigi raamatukogude lugemine koodi algusesse. Enamasti kirjutatakse sisse loetavad raamatukogud kohe R scripti algusesse. Siis on teile endale ja teistele kes teie koodi loevad ilusti näha, mida hiljem vaja läheb. Bibliograafia "],
["calc.html", "3 R on kalkulaator 3.1 Sama koodi saab kirjutada neljal viisil", " 3 R on kalkulaator Liidame 2 + 2. 2 + 2 ## [1] 4 Nüüd trükiti see vastus konsooli kujul [1] 4. See tähendab, et 2 + 2 = 4. Kontrollime seda: ## liidame 2 ja 2 ning vaatame kas vastus võrdub 4 answer &lt;- (2 + 2) == 4 ## Trükime vastuse välja answer ## [1] TRUE Vastus on TRUE, (logical). Pane tähele, et aritmeetiline võrdusmärk on == (sest = tähendab hoopis väärtuse määramist objektile/argumendile). Veel mõned näidisarvutused: ## 3 astmes 2; Please read Note ?&#39;**&#39; 3 ^ 2 ## Ruutjuur 3st sqrt(3) ## Naturaallogaritm sajast log(100) Arvule \\(\\pi\\) on määratud oma objekt pi. Seega on soovitav enda poolt loodavatele objektidele mitte panna nimeks “pi”. ## Ümarda pi neljale komakohale round(pi, 4) ## [1] 3.142 Ümardamine on oluline tulemuste väljaprintimisel. 3.1 Sama koodi saab kirjutada neljal viisil Hargnevate teede aed: kui me muudame olemasolevat objekti on meil alati kaks valikut. Me kas jätame muudetud objektile vana objekti nime või me anname talle uue nime. Esimesel juhul läheb vana muutmata objekt workspacest kaduma aga nimesid ei tule juurde ja säilib teatud workflow sujuvus. Teisel juhul jäävad analüüsi vaheobjektid meile alles ja nende juurde saab alati tagasi tulla. Samas tekkib meile palju sarnaste nimedega objekte. Esimnene võimalus: a &lt;- c(2, 3) a &lt;- sum(a) a &lt;- sqrt(a) a &lt;- round(a, 2) a ## [1] 2.24 Teine võimalus: a &lt;- c(2, 3) a1 &lt;- sum(a) a2 &lt;- sqrt(a1) a3 &lt;- round(a2, 2) a3 ## [1] 2.24 Kolmas võimalus on lühem variant esimesest. Me nimelt ühendame etapid toru %&gt;% kaudu. Siin me võtame objekti “a” (nö. andmed), suuname selle funktsiooni sum(), võtame selle funktsiooni väljundi ja suuname selle omakorda funktsiooni sqrt(). Seejärel võtame selle funktsiooni outputi ja määrame selle nimele “result” (aga võime selle ka mõne teise nimega siduda). Kui mõni funktsioon võtab ainult ühe parameetri, mille me talle toru kaudu sisse sõõdame, siis pole selle funktsiooni taga isegi sulge vaja. NB! R hea stiili juhised soovitavad siiski ka pipe-s kasutada funktsiooni koos sulgudega! See on hea lühike ja inimloetav viis koodi kirjutada, mis on masina jaoks identne esimese koodiga. ## we need piping operator &#39;%&gt;%&#39; from magrittr library(magrittr) a &lt;- c(2, 3) result &lt;- a %&gt;% sum() %&gt;% sqrt() %&gt;% round(2) result ## [1] 2.24 Neljas võimalus, klassikaline baas R lahendus: a &lt;- c(2, 3) a1 &lt;- round(sqrt(sum(a)), 2) a1 ## [1] 2.24 Sellist koodi loetakse keskelt väljappoole ja kirjutatakse alates viimasest operatsioonist, mida soovitakse, et kood teeks. Masina jaoks pole vahet. Inimese jaoks on küll: 4. variant nõuab hästi pestud ajusid. Koodi lühidus 4 –&gt; 3 –&gt; 1 –&gt; 2 (pikem) Lollikindlus 1 –&gt; 2 –&gt; 3 –&gt; 4 (vähem lollikindel) See on teie otsustada, millist koodivormi te millal kasutate, aga te peaksite oskama lugeda neid kõiki. "],
["obj.html", "4 R objektid 4.1 Objekt ja nimi 4.2 Nimede vorm 4.3 Andmete tüübid 4.4 Vektor 4.5 List 4.6 data frame ja tibble 4.7 Tabelit sisse lugedes vaata üle NA-d 4.8 Matrix 4.9 Indekseerimine", " 4 R objektid R-i töökeskkonnas “workspace” asuvad objektid, millega me töötame. Tüüpilised objektid on: Vektorid, maatriksid, listid ja tabelid. Statistiliste analüüside väljundid (S3, S4 klass). Funktsioonid, mille oleme ise sisse lugenud. Käsk ls() annab objektide nimed teie workspace-s: ls() ## [1] &quot;a&quot; &quot;a1&quot; &quot;a2&quot; &quot;a3&quot; &quot;answer&quot; ## [6] &quot;result&quot; rm(a) removes object a from the workspace Selleks, et salvestada töökeskkond faili kasuta “Save” nuppu “Environment” akna servast või menüüst “Session” -&gt; “Save Workspace As”. Projekti sulgemisel salvestab RStudio vaikimisi töökeskkonna. Parema reprodutseeritavuse huvides pole siiski soovitav töökeskkonda peale töö lõppu projekti sulgemisel salvestada!. Lülitame automaatse salvestamise välja: Selleks mine “Tools” &gt; “Global Options” &gt; kõige ülemine, “R General” menüüs vali “Save workspace to .RData on exit” &gt; “Never” ever! Võta ära linnuke “Restore .RData to workspace at startup” eest. Kui on mingid kaua aega võtvad kalkulatsioonid või allalaadimised salvesta need eraldi .rds faili ja laadi koodis vastavalt vajadusele. 4.1 Objekt ja nimi Kui teil sünnib laps, annate talle nime. R-s on vastupidi: nimele antakse objekt babe &lt;- &quot;beebi&quot; babe ## [1] &quot;beebi&quot; Siin on kõigepealt nimi (babe), siis assingmenti sümbol &lt;- ja lõpuks objekt, mis on nimele antud (string “beebi”). NB! Stringid on jutumärkides, nimed mitte. Nimi üksi evalueeritakse kui “print object”, mis antud juhul on string “beebi” Nüüd muudame objekti nime taga: babe &lt;- c(&quot;saatan&quot;, &quot;inglike&quot;) babe ## [1] &quot;saatan&quot; &quot;inglike&quot; Tulemuseks on sama nimi, mis tähistab nüüd midagi muud (vektorit, mis koosneb 2st stringist). Objekt “beebi” kaotas oma nime ja on nüüd workspacest kadunud. class() annab meile objekti klassi. class(babe) ## [1] &quot;character&quot; Antud juhul character. Ainult need objektid, mis on assigneeritud nimele, lähevad workspace ja on sellistena kasutatvad edasises analüüsis. apples &lt;- 2 bananas &lt;- 3 apples + bananas ## [1] 5 Selle ekspressiooni tulemus trükitakse ainult R konsooli, kuna teda ei määrata nimele siis ei ilmu see ka workspace. a &lt;- 2 b &lt;- 3 a &lt;- a + b # objekti nimega &#39;a&#39; struktuur str(a) ## num 5 Nüüd on nimega a seostatud uus objekt, mis sisaldab numbrit 5 (olles ühe elemendiga vektor). Ja nimega a eelnevalt seostatud objekt, mis koosnes numbrist 2, on workspacest lahkunud. 4.2 Nimede vorm Nimed algavad tähemärgiga, mitte numbriga ega $€%&amp;/?~ˇöõüä Nimed ei sisalda tühikuid Tühiku asemel kasuta alakriipsu: näiteks eriti_pikk_nimi SUURED ja väiksed tähed on nimes erinevad Nimed peaksid kirjeldama objekti, mis on sellele nimele assigneeritud ja nad võivad olla pikad sest TAB klahv annab meile auto-complete. alt + - on otsetee &lt;- jaoks 4.3 Andmete tüübid numeric / integer logical – 2 väärtust TRUE/FALSE character factor (ordered and unordered) - 2+ diskreetset väärtust, mis võivad olla järjestatud suuremast väiksemani (aga ei asu üksteisest võrdsel kaugusel). Faktoreid käsitleme põhjalikumalt hiljem. Andmete tüüpe saab üksteiseks konverteerida as.numeric(), as.character(), as.factor(). 4.4 Vektor Vektor on rida kindlas järjekorras arve, sõnu või TRUE/FALSE loogilisi väärtusi. Iga vektor ja maatriks (2D vektor) sisaldab ainult ühte tüüpi andmeid. Vektor on elementaarüksus, millega me teeme tehteid. Andmetabelis ripuvad kõrvuti ühepikad vektorid (üks vektor = üks tulp) ja R-le meeldib arvutada vektori kaupa vasakult paremale (mis tabelis on ülevalt alla sest vektori algus on üleval tabeli peas). Pikema kui üheelemendise vektori loomiseks kasuta funktsiooni c() – combine Loome numbrilise vektori ja vaatame ta struktuuri: minu_vektor &lt;- c(1, 3, 4) str(minu_vektor) ## num [1:3] 1 3 4 Loome vektori puuduva väärtusega, vaatame vektori klassi: minu_vektor &lt;- c(1, NA, 4) minu_vektor ## [1] 1 NA 4 class(minu_vektor) ## [1] &quot;numeric&quot; Klass jääb numeric-uks. Kui vektoris on segamini numbrid ja stringid, siis muudetakse numbrid ka stringideks: minu_vektor &lt;- c(1, &quot;2&quot;, 2, 4, &quot;joe&quot;) minu_vektor ## [1] &quot;1&quot; &quot;2&quot; &quot;2&quot; &quot;4&quot; &quot;joe&quot; class(minu_vektor) ## [1] &quot;character&quot; Piisab ühest “tõrvatilgast meepotis”, et teie vektor ei sisaldaks enam numbreid. Eelnevast segavektorist on võimalik numbrid päästa kasutades käsku as.numeric(): as.numeric(minu_vektor) ## Warning: NAs introduced by coercion ## [1] 1 2 2 4 NA Väärtus “joe” muudeti NA-ks, kuna seda ei olnud võimalik numbriks muuta. Samuti peab olema tähelepanelik faktorite muutmisel numbriteks: minu_vektor &lt;- factor(c(9, &quot;12&quot;, 12, 1.4, &quot;joe&quot;)) minu_vektor ## [1] 9 12 12 1.4 joe ## Levels: 1.4 12 9 joe class(minu_vektor) ## [1] &quot;factor&quot; ## Kui muudame faktori otse numbriks, saame faktori taseme numbri as.numeric(minu_vektor) ## [1] 3 2 2 1 4 Faktorite muutmisel numbriteks tuleb need kõigepealt stringideks muuta: as.numeric(as.character(minu_vektor)) ## Warning: NAs introduced by coercion ## [1] 9.0 12.0 12.0 1.4 NA Järgneva trikiga saab stringidest ekstraheerida numbrid: library(readr) minu_vektor &lt;- c(1, &quot;A2&quot;, &quot;$2&quot;, &quot;joe&quot;) minu_vektor &lt;- as.vector(parse_number(minu_vektor)) ## Warning: 1 parsing failure. ## row # A tibble: 1 x 4 col row col expected actual expected &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; actual 1 4 NA a number joe minu_vektor ## [1] 1 2 2 NA str(minu_vektor) ## num [1:4] 1 2 2 NA R säilitab vektori algse järjekorra. Sageli on aga vaja tulemusi näiteks vaatamiseks ja presenteerimiseks sorteerida suuruse või tähestiku järjekorras: ## sorts vector in ascending order sort(x, decreasing = FALSE, ...) Vektori unikaalsed väärtused saab kätte käsuga unique(): ## returns a vector or data frame, but with duplicate elements/rows removed unique(c(1,1,1,2,2,2,2,2,3,3,4,5,5)) ## [1] 1 2 3 4 5 4.4.1 Uus vektor: seq() ja rep() seq(2, 3, by = 0.5) ## [1] 2.0 2.5 3.0 seq(2, 3, length.out = 5) ## [1] 2.00 2.25 2.50 2.75 3.00 rep(1:2, times = 3) ## [1] 1 2 1 2 1 2 rep(1:2, each = 3) ## [1] 1 1 1 2 2 2 rep(c(&quot;a&quot;, &quot;b&quot;), each = 3, times = 2) ## [1] &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;b&quot; &quot;b&quot; &quot;b&quot; &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;b&quot; &quot;b&quot; &quot;b&quot; 4.4.2 Tehted arvuliste vektoritega Vektoreid saab liita, lahutada, korrutada ja jagada. a &lt;- c(1, 2, 3) b &lt;- 4 a + b ## [1] 5 6 7 Kõik vektor a liikmed liideti arvuga 3 (kuna vektor b koosnes ühest liikmest, läks see kordusesse) a &lt;- c(1, 2, 3) b &lt;- c(4, 5) a + b ## Warning in a + b: longer object length is not a ## multiple of shorter object length ## [1] 5 7 7 Aga see töötab veateatega, sest vektorite pikkused ei ole üksteise kordajad 1 + 4; 2 + 5, 3 + 4 a &lt;- c(1, 2, 3, 4) b &lt;- c(5, 6) a + b ## [1] 6 8 8 10 See töötab: 1 + 5; 2 + 6; 3 + 5; 4 + 6 a &lt;- c(1, 2, 3, 4) b &lt;- c(5, 6, 7, 8) a + b ## [1] 6 8 10 12 Samuti see (ühepikkused vektorid — igat liiget kasutatakse üks kord) a &lt;- c(TRUE, FALSE, TRUE) sum(a) ## [1] 2 mean(a) ## [1] 0.6667 Mis siin juhtus? R kodeerib sisemiselt TRUE kui 1 ja FALSE kui 0-i. summa 1 + 0 + 1 = 2. Seda loogiliste väärtuste omadust õpime varsti praktikas kasutama. 4.5 List List on objektitüüp, kuhu saab koondada kõiki teisi objekte, kaasa arvatud listid. See on lihtsalt viis objektid koos hoida ühes suuremas meta-objektis. List on nagu jõuluvana kingikott, kus kommid, sokipaarid ja muud kingid kõik segamini loksuvad. Näiteks siin list, kus loksuvad 1 vektor nimega a, 1 tibble nimega b ja 1 list nimega c, mis omakorda sisaldab vektorit nimega d ja tibblet nimega e. Seega on meil tegu rekursiivse listiga. # numeric vector a a &lt;- runif(5) # data.frame ab &lt;- data.frame(a, b = rnorm(5)) # linear model model &lt;- lm(mpg ~ hp, data = mtcars) # your grandma on bongos grandma &lt;- &quot;your grandma on bongos&quot; # let&#39;s creat list happy_list &lt;- list(a, ab, model, grandma) happy_list ## [[1]] ## [1] 0.5756958 0.6427499 0.1277765 0.3864125 0.0008077 ## ## [[2]] ## a b ## 1 0.5756958 1.3634 ## 2 0.6427499 1.1262 ## 3 0.1277765 -0.4297 ## 4 0.3864125 1.3610 ## 5 0.0008077 0.9538 ## ## [[3]] ## ## Call: ## lm(formula = mpg ~ hp, data = mtcars) ## ## Coefficients: ## (Intercept) hp ## 30.0989 -0.0682 ## ## ## [[4]] ## [1] &quot;your grandma on bongos&quot; Võtame listist välja elemndi “ab”: happy_list$ab ## NULL 4.6 data frame ja tibble library(tidyverse) ## Loading tidyverse: ggplot2 ## Loading tidyverse: tibble ## Loading tidyverse: tidyr ## Loading tidyverse: purrr ## Conflicts with tidy packages -------------------------- ## filter(): dplyr, stats ## lag(): dplyr, stats Andmeraam on eriline list, mis koosneb ühepikkustest vektoritest. Andmeraam on ühtlasi teatud liiki tabel, kus igas veerus on ainult ühte tüüpi andmed. Need vektorid ripuvad andmeraamis kõrvuti nagu tuulehaugid suitsuahjus, kusjuures vektori algus vastab tuulehaugi peale, mis on konksu otsas (konks vastab andmeraamis tulba nimele ja ühtlasi vektori nimele). Iga vektori nimi muutub sellises tabelis tulba nimeks. Igas tulbas saab olla ainult ühte tüüpi andmeid. R-s on 2 andmeraami tüüpi: data frame ja tibble, mis on väga sarnased. Tibble on uuem, veidi kaunima väljatrükiga, pisut mugavam kasutada. Oluline on, et erinevalt data frame-st saab tibblesse lisada ka list tulpasid, mis võimaldab sisuliselt suvalisi R objekte tibblesse paigutada. Põhimõtteliselt piisab ainult ühest andmestruktuurist – tibble, et R-is töötada. Kõik mis juhtub tibbles jääb tibblesse. Nice and tidy – tidyverse. “Tidyverse” töötab tibblega veidi paremini kui data frame-ga, aga see vahe ei ole suur. Siin on meil 3 vektorit: shop, apples ja oranges, millest me paneme kokku tibble nimega fruits ## loome kolm vektorit shop &lt;- c(&quot;maxima&quot;, &quot;tesco&quot;, &quot;lidl&quot;) apples &lt;- c(1, 4, 43) oranges &lt;- c(2, 32, NA) vabakava &lt;- list(letters, runif(10), lm(mpg ~ cyl, mtcars)) ## paneme need vektorid kokku tibble-sse fruits &lt;- tibble(shop, apples, oranges, vabakava) fruits ## # A tibble: 3 x 4 ## shop apples oranges vabakava ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;list&gt; ## 1 maxima 1 2 &lt;chr [26]&gt; ## 2 tesco 4 32 &lt;dbl [10]&gt; ## 3 lidl 43 NA &lt;S3: lm&gt; Siin ta on, ilusti meie workspace-s. Pange tähele viimast tulpa “vabakava”, mis sisaldab character vectorit, numbrilist vektorit ja lineaarse mudeli objekti. Listi juba nii lihtsalt data.frame-i ei pane: dfs &lt;- try(data.frame(shop, apples, oranges, vabakava)) dfs ## [1] &quot;Error in as.data.frame.default(x[[i]], optional = TRUE, stringsAsFactors = stringsAsFactors) : \\n cannot coerce class \\&quot;\\&quot;lm\\&quot;\\&quot; to a data.frame\\n&quot; ## attr(,&quot;class&quot;) ## [1] &quot;try-error&quot; ## attr(,&quot;condition&quot;) ## &lt;simpleError in as.data.frame.default(x[[i]], optional = TRUE, stringsAsFactors = stringsAsFactors): cannot coerce class &quot;&quot;lm&quot;&quot; to a data.frame&gt; Mõned asjad, mida tibblega (ja data framega) saab teha: count(fruits, apples) ## # A tibble: 3 x 2 ## apples n ## &lt;dbl&gt; &lt;int&gt; ## 1 1 1 ## 2 4 1 ## 3 43 1 count(fruits, shop) ## # A tibble: 3 x 2 ## shop n ## &lt;chr&gt; &lt;int&gt; ## 1 lidl 1 ## 2 maxima 1 ## 3 tesco 1 summary(fruits) ## shop apples oranges ## Length:3 Min. : 1.0 Min. : 2.0 ## Class :character 1st Qu.: 2.5 1st Qu.: 9.5 ## Mode :character Median : 4.0 Median :17.0 ## Mean :16.0 Mean :17.0 ## 3rd Qu.:23.5 3rd Qu.:24.5 ## Max. :43.0 Max. :32.0 ## NA&#39;s :1 ## vabakava.Length vabakava.Class vabakava.Mode ## 26 -none- character ## 10 -none- numeric ## 12 lm list ## ## ## ## names(fruits) ## [1] &quot;shop&quot; &quot;apples&quot; &quot;oranges&quot; &quot;vabakava&quot; colnames(fruits) ## [1] &quot;shop&quot; &quot;apples&quot; &quot;oranges&quot; &quot;vabakava&quot; nrow(fruits) ## [1] 3 ncol(fruits) ## [1] 4 arrange(fruits, desc(apples)) #sorteerib tabeli veeru &quot;apples&quot; väärtuste järgi langevalt (default on tõusev sorteerimine). Võib argumendina anda mitu veergu. ## # A tibble: 3 x 4 ## shop apples oranges vabakava ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;list&gt; ## 1 lidl 43 NA &lt;S3: lm&gt; ## 2 tesco 4 32 &lt;dbl [10]&gt; ## 3 maxima 1 2 &lt;chr [26]&gt; top_n(fruits, 2, apples) #saab 2 rida, milles on kõige rohkem õunu ## # A tibble: 2 x 4 ## shop apples oranges vabakava ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;list&gt; ## 1 tesco 4 32 &lt;dbl [10]&gt; ## 2 lidl 43 NA &lt;S3: lm&gt; top_n(fruits, -2, apples) #saab 2 rida, milles on kõige vähem õunu ## # A tibble: 2 x 4 ## shop apples oranges vabakava ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;list&gt; ## 1 maxima 1 2 &lt;chr [26]&gt; ## 2 tesco 4 32 &lt;dbl [10]&gt; Tibblega saab teha maatriksarvutusi, kui kasutada ainult arvudega ridu. apply() arvutab maatriksi rea (1) või veeru (2) kaupa, vastavalt funktsioonile, mille sa ette annad. colSums(fruits[ , 2:3]) ## apples oranges ## 48 NA rowSums(fruits[ , 2:3]) ## [1] 3 36 NA rowMeans(fruits[ , 2:3]) ## [1] 1.5 18.0 NA colMeans(fruits[ , 2:3]) ## apples oranges ## 16 NA fruits_subset &lt;- fruits[ , 2:3] # 1 tähendab, et arvuta sd rea kaupa apply(fruits_subset, 1, sd) ## [1] 0.7071 19.7990 NA # 2 tähendab, et arvuta sd veeru kaupa apply(fruits_subset, 2, sd) ## apples oranges ## 23.43 NA Lisame käsitsi meie tabelile 1 rea: fruits &lt;- add_row(fruits, shop = &quot;konsum&quot;, apples = 132, oranges = -5, .before = 3) fruits ## # A tibble: 4 x 4 ## shop apples oranges vabakava ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;list&gt; ## 1 maxima 1 2 &lt;chr [26]&gt; ## 2 tesco 4 32 &lt;dbl [10]&gt; ## 3 konsum 132 -5 &lt;NULL&gt; ## 4 lidl 43 NA &lt;S3: lm&gt; Proovi ise: add_column() Eelnevaid verbe ei kasuta me vist enam kunagi sest tavaliselt loeme me andmed sisse väljaspoolt R-i. Aga väga kasulikud on järgmised käsud: 4.6.1 Rekodeerime tibble väärtusi fruits$apples[fruits$apples==43] &lt;- 333 fruits ## # A tibble: 4 x 4 ## shop apples oranges vabakava ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;list&gt; ## 1 maxima 1 2 &lt;chr [26]&gt; ## 2 tesco 4 32 &lt;dbl [10]&gt; ## 3 konsum 132 -5 &lt;NULL&gt; ## 4 lidl 333 NA &lt;S3: lm&gt; fruits$shop[fruits$shop==&quot;tesco&quot;] &lt;- &quot;TESCO&quot; fruits ## # A tibble: 4 x 4 ## shop apples oranges vabakava ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;list&gt; ## 1 maxima 1 2 &lt;chr [26]&gt; ## 2 TESCO 4 32 &lt;dbl [10]&gt; ## 3 konsum 132 -5 &lt;NULL&gt; ## 4 lidl 333 NA &lt;S3: lm&gt; fruits$apples[fruits$apples&gt;100] &lt;- NA fruits ## # A tibble: 4 x 4 ## shop apples oranges vabakava ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;list&gt; ## 1 maxima 1 2 &lt;chr [26]&gt; ## 2 TESCO 4 32 &lt;dbl [10]&gt; ## 3 konsum NA -5 &lt;NULL&gt; ## 4 lidl NA NA &lt;S3: lm&gt; Remove duplicate rows where specific column (col1) contains duplicated values: distinct(dat, col1, .keep_all = TRUE) # kõikide col vastu distinct(dat) Rekodeerime Inf ja NA väärtused nulliks (väga halb mõte): # inf to 0 x[is.infinite(x)] &lt;- 0 # NA to 0 x[is.na(x)] &lt;- 0 4.6.2 Ühendame kaks tibblet rea kaupa Tabeli veergude arv ei muutu, ridade arv kasvab. dfs &lt;- tibble(colA = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), colB = c(1, 2, 3)) dfs1 &lt;- tibble(colA = &quot;d&quot;, colB = 4) #id teeb veel ühe veeru, mis näitab, kummast algtabelist iga uue tabeli rida pärit on bind_rows(dfs, dfs1, .id = &quot;id&quot;) ## # A tibble: 4 x 3 ## id colA colB ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1 a 1 ## 2 1 b 2 ## 3 1 c 3 ## 4 2 d 4 Vaata Environmendist need tabelid üle ja mõtle järgi, mis juhtus. Kui bind_rows() miskipärast ei tööta, proovi do.call(rbind, dfs), mis on väga sarnane. NB! Alati kontrollige, et ühendatud tabel oleks selline, nagu te tahtsite! Näiteks, võib-olla te tahtsite järgnevat tabelit saada, aga võib-olla ka mitte: df2 &lt;- tibble(ColC = &quot;d&quot;, ColD = 4) ## works by guessing your true intention bind_rows(dfs1, df2) ## # A tibble: 2 x 4 ## colA colB ColC ColD ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 d 4 &lt;NA&gt; NA ## 2 &lt;NA&gt; NA d 4 4.6.3 ühendame kaks tibblet veeru kaupa Meil on 2 verbi: bind_cols ja cbind, millest esimene on konservatiivsem. Proovige eelkõige bind_col-ga läbi saada, aga kui muidu ei saa, siis cbind ühendab vahest asju, mida bind_cols keeldub puutumast. NB! Alati kontrollige, et ühendatud tabel oleks selline, nagu te tahtsite! dfx &lt;- tibble(colC = c(4, 5, 6)) cbind(dfs, dfx) ## colA colB colC ## 1 a 1 4 ## 2 b 2 5 ## 3 c 3 6 4.6.4 Nii saab tibblest kätte vektori, millega saab tehteid teha. Tibble jääb muidugi endisel kujul alles. ubinad &lt;- fruits$apples ubinad &lt;- ubinad + 2 ubinad ## [1] 3 6 NA NA ## see on jälle vektor str(ubinad) ## num [1:4] 3 6 NA NA 4.6.5 Andmeraamide salvestamine (eksport-import) Andmeraami saame salvestada näiteks csv-na (comma separated file) oma kõvakettale, kasutame “tidyverse” analooge paketist “readr”, mille nimed on baas R funktsioonidest eristatavad alakriipsu “_&quot; kasutamisega. “readr” laaditakse “tidyverse” laadimisega. ## loome uuesti fruits data tibble shop &lt;- c(&quot;maxima&quot;, &quot;tesco&quot;, &quot;lidl&quot;) apples &lt;- c(1, 4, 43) oranges &lt;- c(2, 32, NA) fruits &lt;- tibble(shop, apples, oranges, vabakava) ## kirjutame fruits tabeli csv faili fruits.csv kataloogi data write_csv(fruits, &quot;data/fruits.csv&quot;) Kuhu see fail läks? See läks meie projekti juurkataloogi kausta “data/”, juurkataloogi asukoha oma arvuti kõvakettal leiame käsuga: getwd() ## [1] &quot;/Users/taavi/Dropbox/2017-R-course/lectures&quot; Andmete sisselugemine töökataloogist: fruits &lt;- read_csv(&quot;data/fruits.csv&quot;) MS exceli failist saab tabeleid importida “readxl” paki abil. library(readxl) ## kõigepealt vaatame kui palju sheete failis on sheets &lt;- excel_sheets(&quot;data/excelfile.xlsx&quot;) ## siis impordime näiteks esimese sheeti dfs &lt;- read_excel(&quot;data/excelfile.xlsx&quot;, sheet = sheets[1]) Excelist csv-na eksporditud failid tuleks sisse lugeda käsuga read_csv2 või read.csv2 (need on erinevad funktsioonid; read.csv2 loeb selle sisse data framena ja read_csv2 tibble-na). R-i saab sisse lugeda palju erinevaid andmeformaate. Kui sa soovid oluliselt ohverdada reprodutseeritavust installi RStudio addin: “Gotta read em all R”. See läheb ülesse tab-i Addins. Sealt saab selle avada ja selle abil tabeleid oma workspace üles laadida. Selline point-and-click lahendus sobib ehk tabelite esialgseks tutvumiseks, kuid korrektne on andmed importida programmaatiliselt oma skriptis. #install gotta read em all as R studio addin install.packages(&quot;devtools&quot;) devtools::install_github(&quot;Stan125/GREA&quot;) Alternatiiv: mine alla paremake Files tab-le, navigeeri sinna kuhu vaja ja kliki faili nimele, mida tahad R-i importida. Mõlemal juhul ilmub alla konsooli (all vasakul) koodijupp, mille jooksutamine peaks asja ära tegema. Te võite tahta selle koodi kopeerida üles vasakusse aknasse kus teie ülejäänud kood tulevastele põlvedele säilub. Tüüpiliselt töötate R-s oma algse andmestikuga. Reprodutseeruvaks projektiks on vaja 2 asja: algandmeid ja koodi, millega neid manipuleerida. NB! R ei muuda algandmeid, mille te näiteks csv-na sisse loete - need jäävad alati selliseks nagu need instrumendi või andmesisestaja poolt väljastati. Seega ei ole andmetabelite salvestamine töö vaheproduktidena sageli vajalik sest te jooksutate iga kord, kui te oma projekti juurde naasete, kogu analüüsi uuesti kuni kohani, kuhu te pooleli jäite. See tagab kõige paremini, et teie kood töötab tervikuna. Erandiks on tabelid, mille arvutamine palju aega võtab. Tibble konverteerimine data frame-ks ja tagasi tibbleks: class(fruits) ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; fruits &lt;- as.data.frame(fruits) class(fruits) ## [1] &quot;data.frame&quot; fruits &lt;- as_tibble(fruits) class(fruits) ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; 4.7 Tabelit sisse lugedes vaata üle NA-d library(VIM) ## Loading required package: colorspace ## Loading required package: grid ## Loading required package: data.table ## ## Attaching package: &#39;data.table&#39; ## The following object is masked from &#39;package:purrr&#39;: ## ## transpose ## The following objects are masked from &#39;package:dplyr&#39;: ## ## between, first, last ## VIM is ready to use. ## Since version 4.0.0 the GUI is in its own package VIMGUI. ## ## Please use the package to use the new (and old) GUI. ## Suggestions and bug-reports can be submitted at: https://github.com/alexkowa/VIM/issues ## ## Attaching package: &#39;VIM&#39; ## The following object is masked from &#39;package:datasets&#39;: ## ## sleep diabetes &lt;- read.table(file = &quot;data/diabetes.csv&quot;, sep = &quot;;&quot;, dec = &quot;,&quot;, header = TRUE) str(diabetes) ## &#39;data.frame&#39;: 403 obs. of 19 variables: ## $ id : int 1000 1001 1002 1003 1005 1008 1011 1015 1016 1022 ... ## $ chol : int 203 165 228 78 249 248 195 227 177 263 ... ## $ stab.glu: int 82 97 92 93 90 94 92 75 87 89 ... ## $ hdl : int 56 24 37 12 28 69 41 44 49 40 ... ## $ ratio : num 3.6 6.9 6.2 6.5 8.9 ... ## $ glyhb : num 4.31 4.44 4.64 4.63 7.72 ... ## $ location: Factor w/ 2 levels &quot;Buckingham&quot;,&quot;Louisa&quot;: 1 1 1 1 1 1 1 1 1 1 ... ## $ age : int 46 29 58 67 64 34 30 37 45 55 ... ## $ gender : Factor w/ 2 levels &quot;female&quot;,&quot;male&quot;: 1 1 1 2 2 2 2 2 2 1 ... ## $ height : int 62 64 61 67 68 71 69 59 69 63 ... ## $ weight : int 121 218 256 119 183 190 191 170 166 202 ... ## $ frame : Factor w/ 4 levels &quot;&quot;,&quot;large&quot;,&quot;medium&quot;,..: 3 2 2 2 3 2 3 3 2 4 ... ## $ bp.1s : int 118 112 190 110 138 132 161 NA 160 108 ... ## $ bp.1d : int 59 68 92 50 80 86 112 NA 80 72 ... ## $ bp.2s : int NA NA 185 NA NA NA 161 NA 128 NA ... ## $ bp.2d : int NA NA 92 NA NA NA 112 NA 86 NA ... ## $ waist : int 29 46 49 33 44 36 46 34 34 45 ... ## $ hip : int 38 48 57 38 41 42 49 39 40 50 ... ## $ time.ppn: int 720 360 180 480 300 195 720 1020 300 240 ... aggr(diabetes, prop = FALSE, numbers = TRUE) Siit on näha, et kui me viskame välja 2 tulpa ja seejärel kõik read, mis sisaldavad NA-sid, kaotame me umbes 20 rida 380-st, mis ei ole suur kaotus. Kui palju ridu, milles on 0 NA-d? Mitu % kõikidest ridadest? nrows &lt;- nrow(diabetes) ncomplete &lt;- sum(complete.cases(diabetes)) ncomplete #136 ## [1] 136 ncomplete/nrows #34% ## [1] 0.3375 Mitu NA-d on igas tulbas? sapply(diabetes, function(x) sum(is.na(x))) ## id chol stab.glu hdl ratio glyhb ## 0 1 0 1 1 13 ## location age gender height weight frame ## 0 0 0 5 1 0 ## bp.1s bp.1d bp.2s bp.2d waist hip ## 5 5 262 262 2 2 ## time.ppn ## 3 Ploti NAd punasega igale tabeli reale ja tulbale mida tumedam halli toon seda suurem number selle tulba kontekstis: matrixplot(diabetes) ## ## Click in a column to sort by the corresponding variable. ## To regain use of the VIM GUI and the R console, click outside the plot region. Kuidas rekodeerida NA-d näiteks 0-ks: dfs[is.na(dfs)] &lt;- 0 dfs[is.na(dfs)] &lt;- &quot;other&quot; dfs[dfs == 0] &lt;- NA # teeb vastupidi 0-d NA-deks Pane tähele, et NA tähistamine ei käi character vectorina vaid dedikeeritud is.na() funktsiooniga. 4.8 Matrix Maatriks on 2-dimensionaalne vektor, sisaldab ainult ühte tüüpi andmeid – numbrid, stringid, faktorid. Tip: me saame sageli andmeraami maatriksina kasutada kui me viskame sealt välja mitte-numbrilised tulbad. Aga saame ka andmeraame konverteerida otse maatriksiks (ja tagasi). fruits &lt;- as.matrix(fruits) class(fruits) 4.9 Indekseerimine Igale vektori, listi, andmeraami ja maatriksi elemendile vastab unikaalne postiindeks, mille abil saame just selle elemendi unikaalselt indentifitseerida, välja võtta ja töödelda. Seega on indeksi mõte väga lühikese käsuga välja võtta R-i objektide üksikuid elemente. R-s algab indeksi numeratsioon 1-st (mitte 0-st, nagu näiteks Pythonis). 4.9.1 Vektorid ja nende indeksid on ühedimensionaalsed my_vector &lt;- 2:5 my_vector ## [1] 2 3 4 5 my_vector[1] #1. element ehk number 2 ## [1] 2 my_vector[c(1,3)] #1. ja 3. element ## [1] 2 4 my_vector[-1] #kõik elemendid, v.a. element number 1 ## [1] 3 4 5 my_vector[c(-1, -3)] #kõik elemendid, v.a. element number 1 ja 3 ## [1] 3 5 my_vector[3:5] #elemendid 3, 4 ja 5 (element 5 on määramata, seega NA) ## [1] 4 5 NA my_vector[-(3:length(my_vector))] #1. ja 2. element ## [1] 2 3 4.9.2 Andmeraamid ja maatriksid on kahedimensionaalsed, nagu ka nende indeksid 2D indeksi kuju on [rea_indeks, veeru_indeks]. dat &lt;- tibble(colA = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), colB = c(1, 2, 3)) dat # üks andmepunkt: 1 rida, 2. veerg dat[1, 2] # 1. rida, kõik veerud dat[1, ] # 2. veerg, kõik read dat[, 2] # kõik read peale 1. dat[-1, ] # viskab välja 2. veeru dat[, -2] # 2 andmepunkti: 2. rida, 1. ja 2. veerg dat[2, 1:2] # 2 andmepunkti: 2. rida, 3. ja 4. veerg dat[2, c(1, 2)] #viskab välja 1. ja 2. rea dat[-c(1, 2), ] #veerg nimega colB, output on erandina vektor! dat$colB Kui me indekseerimisega tibblest veeru ehk vektori välja võtame, on output class: tibble. Kui me teeme sama data frame-st, siis on output class: vector. Nüüd veidi keerulisemad konstruktsioonid, mis võimaldavad tabeli ühe kindla veeru väärtusi välja tõmmata teise veeru väärtuste järgi filteerides. Püüdke sellest koodist aru saada, et te hiljem ära tunneksite, kui midagi sellist vastu tuleb. Õnneks ei ole teil endil vaja sellist koodi kirjutada, me õpetame teile varsti lihtsama filtri meetodi. dat &lt;- tibble(colA = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), colB = c(1, 2, 3)) dat$colB[dat$colA != &quot;a&quot; ] #jätab sisse kõik vektori colB väärtused, kus samas tabeli reas olev colA väärtus ei ole &quot;a&quot;. output on vektor! ## [1] 2 3 dat$colA[dat$colB &gt; 1] #jätab sisse kõik vektori colA väärtused, kus samas tabeli reas olev colB väärtus &gt;1. output on vektor. ## [1] &quot;b&quot; &quot;c&quot; 4.9.3 Listide indekseerimine Listi indekseerimisel kasutame kahte sorti nurksulge, “[ ]” ja “[[ ]]”, mis töötavad erinevalt. Kui listi vaadata nagu objektide vanglat, siis kaksiksulgude [[ ]] abil on võimalik üksikuid objekte vanglast välja päästa nii, et taastub nende algne kuju ehk class. Seevastu üksiksulud [ ] tekitavad uue listi, kus on säilinud osad algse listi elemendid, ehk uue vangla vähemate vangidega. Kaksiksulud “[[ ]]” päästavad listist välja ühe elemendi ja taastavad selle algse class-i (data.frame, vektor, list jms). Üksiksulud “[ ]” võtavad algsest listist välja teie poolt valitud elemendid aga jätavad uue objekti ikka listi kujule. my_list &lt;- list(a = tibble(colA = c(&quot;A&quot;, &quot;B&quot;), colB = c(1, 2)), b = c(1, NA, &quot;s&quot;)) ## this list has two elements, a data frame called &quot;a&quot; and a character vector called &quot;b&quot;. str(my_list) ## List of 2 ## $ a:Classes &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;: 2 obs. of 2 variables: ## ..$ colA: chr [1:2] &quot;A&quot; &quot;B&quot; ## ..$ colB: num [1:2] 1 2 ## $ b: chr [1:3] &quot;1&quot; NA &quot;s&quot; Tõmbame listist välja tibble: my_tibble &lt;- my_list[[1]] my_tibble ## # A tibble: 2 x 2 ## colA colB ## &lt;chr&gt; &lt;dbl&gt; ## 1 A 1 ## 2 B 2 See ei ole enam list. Nüüd võtame üksiksuluga listist välja 1. elemendi, mis on tibble, aga output ei ole mitte tibble, vaid ikka list. Seekord ühe elemendiga, mis on tibble. aa &lt;- my_list[1] str(aa) ## List of 1 ## $ a:Classes &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;: 2 obs. of 2 variables: ## ..$ colA: chr [1:2] &quot;A&quot; &quot;B&quot; ## ..$ colB: num [1:2] 1 2 aa1 &lt;- my_list$a[2,] #class is df aa1 ## # A tibble: 1 x 2 ## colA colB ## &lt;chr&gt; &lt;dbl&gt; ## 1 B 2 aa3 &lt;- my_list[[1]][1,] aa3 ## # A tibble: 1 x 2 ## colA colB ## &lt;chr&gt; &lt;dbl&gt; ## 1 A 1 Kõigepealt läksime kaksiksulgudega listi taseme võrra sisse ja võtsime välja objekti my_list 1. elemendi, tema algses tibble formaadis, (indeksi 1. dimensioon). Seejärel korjame sealt välja 1. rea, tibble formaati muutmata ja seega üksiksulgudes (indeksi 2. ja 3. dimensioon). Pane tähele, et [[ ]] lubab ainult ühe elemendi korraga listist välja päästa. "],
["regex.html", "5 Regular expression ja find &amp; replace 5.1 Common operations with regular expressions 5.2 Find and replace", " 5 Regular expression ja find &amp; replace Regular expression annab võimaluse lühidalt kirjeldada mitte-üheseid otsinguparameetreid. regular expression on string, mis kirjeldab mitut stringi A regular expression Regular Expressions as used in R Most characters, including all letters and digits, are regular expressions that match themselves. . matches any single character. You can refer also to a character class, which is a list of characters enclosed between [ and ], e.g. [[:alnum:]] is same as [A-z0-9]. Most common character classes: [:alnum:] includes alphanumerics ([:alpha:] and [:digit:]); [:alpha:], includes alphabetic characters ([:upper:] and [:lower:] case); [:punct:] includes punctuation characters ! &quot; # $ % &amp; ’ ( ) * + , - . / : ; &lt; = &gt; ? @ [ ] ^ _ ` ` { | } ~.; [:blank:] includes space and tab; etc. The metacharacters in regular expressions are . \\ | ( ) [ { ^ $ * + ?, whether these have a special meaning depends on the context. When matching a metacharacter as a regular character, precede it with a double backslash \\\\. Repetition quantifiers put after regex specify how many times regex is matched: ?, optional, at most once; *, zero or more times; +, one or more times; {n}, n times; {n,}, n or more times; {n,m}, n to m times. ^ anchors the regular expression to the start of the string. $ anchors the the regular expression to end of the string. 5.1 Common operations with regular expressions Locate a pattern match (positions) Extract a matched pattern Identify a match to a pattern Replace a matched pattern 5.2 Find and replace library(stringr) x&lt;- c(&quot;apple&quot;, &quot;ananas&quot;, &quot;banana&quot;) #replaces all a-s at the beginning of strings with e-s str_replace(x, &quot;^a&quot;, &quot;e&quot;) ## [1] &quot;epple&quot; &quot;enanas&quot; &quot;banana&quot; # str_replace only replaces at the first occurence at each string str_replace(x, &quot;a&quot;, &quot;e&quot;) ## [1] &quot;epple&quot; &quot;enanas&quot; &quot;benana&quot; #str_replace_all replaces all a-s anywhere in the strings str_replace_all(x, &quot;a&quot;, &quot;e&quot;) ## [1] &quot;epple&quot; &quot;enenes&quot; &quot;benene&quot; #replaces a and the following character at the end of string with nothing (i.e. deletes 2 chars) str_replace(x, &quot;a.$&quot;, &quot;&quot;) ## [1] &quot;apple&quot; &quot;anan&quot; &quot;banana&quot; #replaces a-s or s-s at the end of string with e-s str_replace(x, &quot;(a|s)$&quot;, &quot;e&quot;) ## [1] &quot;apple&quot; &quot;ananae&quot; &quot;banane&quot; #replaces a-s or s-s anywhere in the string with e-s str_replace_all(x, &quot;a|s&quot;, &quot;e&quot;) ## [1] &quot;epple&quot; &quot;enenee&quot; &quot;benene&quot; #remove all numbers. y&lt;-c(&quot;as1&quot;, &quot;2we3w&quot;, &quot;3e&quot;) str_replace_all(y, &quot;\\\\d&quot;, &quot;&quot;) ## [1] &quot;as&quot; &quot;wew&quot; &quot;e&quot; #remove everything, except numbers. str_replace_all(y, &quot;[A-Za-z_]&quot;, &quot;&quot;) ## [1] &quot;1&quot; &quot;23&quot; &quot;3&quot; x&lt;- c(&quot;apple&quot;, &quot;apple pie&quot;) str_replace_all(x, &quot;^apple$&quot;,&quot;m&quot;) #To force to only match a complete string: ## [1] &quot;m&quot; &quot;apple pie&quot; str_replace_all(x, &quot;\\\\s&quot;,&quot;_&quot;) #space to _ ## [1] &quot;apple&quot; &quot;apple_pie&quot; str_replace_all(x, &quot;[apl]&quot;,&quot;_&quot;) #a or p or l to _ ## [1] &quot;____e&quot; &quot;____e _ie&quot; str_replace_all(x, &quot;[ap|p.e]&quot;,&quot;_&quot;) # ap or p.e to _ ## [1] &quot;___l_&quot; &quot;___l_ _i_&quot; patterns that match more than one character: . (dot): any character apart from a newline. \\\\d: any digit. \\\\s: any whitespace (space, tab, newline). \\[abc]: match a, b, or c. \\[!abc]: match anything except a, b, or c. To create a regular expression containing \\d or \\s, you???ll need to escape the \\ for the string, so you will type &quot;\\\\\\\\d&quot; or &quot;\\\\\\\\s&quot;. abc|d..f will match either &quot;abc&quot;, or &quot;deaf&quot;. "],
["funs.html", "6 Funktsioonid on R keele verbid 6.1 Kirjutame R funktsiooni", " 6 Funktsioonid on R keele verbid Kasutaja ütleb nii täpselt kui oskab, mida ta tahab ja R-s elab kratt, kes püüab ära arvata, mida on vaja teha. Vahest teeb kah. Vahest isegi seda, mida kasutaja tahtis. Mõni arvab, et R-i puudus on veateadete puudumine või krüptilised veateated. Sama kehtib ka R-i helpi kohta. Seega tasub alati kontrollida, kas R ikka tegi seda, mida sina talle enda arust ette kirjutasid. Paljudel juhtudel ütleb (hea) funktsiooni nimi mida see teeb: # create two test vectors x &lt;- c(6, 3, 3, 4, 5) y &lt;- c(1, 3, 4, 2, 7) # calculate correlation cor(x, y) ## [1] -0.1166 # calculate sum sum(x) ## [1] 21 # calculate sum of two vectors sum(x, y) ## [1] 38 # calculate average mean(x) ## [1] 4.2 # calculate median median(x) ## [1] 4 # calculate standard deviation sd(x) ## [1] 1.304 # return quantiles quantile(x) ## 0% 25% 50% 75% 100% ## 3 3 4 5 6 # return maximum value max(x) ## [1] 6 # return minimum value min(x) ## [1] 3 R-is teevad asju programmikesed, mida kutsutakse funktsioonideks. Te võite mõelda funktsioonist nagu verbist. Näiteks funktsiooni sum() korral loe: “võta summa”. Iga funktsiooni nime järel on sulud. Nende sulgude sees asuvad selle funktsiooni argumendid. Argumendid määravad ära funktsiooni käitumise. Et näha, millised argumendid on funktsiooni käivitamiseks vajalikud ja milliseid on üldse võimalik seadistada, kasuta ‘help’ käsku. ?sum Help paneelis paremal all ilmub nüüd selle funktsiooni R dokumentatsioon. Vaata seal peatükki Usage: sum(..., na.rm = FALSE) ja edasi peatükki Arguments, mis ütleb, et ... (ellipsis) tähistab vektoreid. sum {base} R Documentation Sum of Vector Elements Description: sum returns the sum of all the values present in its arguments. Usage sum(..., na.rm = FALSE) Arguments ... - numeric or complex or logical vectors. na.rm - logical. Should missing values (including NaN) be removed? Seega võtab funktsioon sum() kaks argumenti: vektori arvudest (või loogilise vektori, mis koosneb TRUE ja FALSE määrangutest), ning “na.rm” argumendi, millele saab anda väärtuseks kas, TRUE või FALSE. Usage ütleb ka, et vaikimisi on na.rm = FALSE, mis tähendab, et sellele argumendile on antud vaikeväärtus – kui me seda ise ei muuda, siis jäävad NA-d arvutusse sisse. Kuna NA tähendab “tundmatu arv” siis iga tehe NA-dega annab vastuseks “tundmatu arv” ehk NA (tundmatu arv + 2 = tundmatu arv). Seega NA tulemus annab märku, et teie andmetes võib olla midagi valesti. ## moodustame vektori apples &lt;- c(1, 34, 43, NA) ## arvutame summa sum(apples, na.rm = TRUE) ## [1] 78 Niimoodi saab arvutada summat vektorile nimega “apples”. Sisestades R käsureale funktsiooni ilma selle sulgudeta saab masinast selle funktsiooni koodi. Näiteks: sum ## function (..., na.rm = FALSE) .Primitive(&quot;sum&quot;) Tulemus näitab, et sum() on Primitive funktsioon, mis põhimõtteliselt tähendab, et ta põhineb C koodil ja ei kasuta R koodi. 6.1 Kirjutame R funktsiooni Võib ju väita, et funktsiooni ainus mõte on peita teie eest korduvad vajalikud koodiread kood funktsiooni nime taha. Põhjus, miks R-s on funktsioonid, on korduse vähendamine, koodi loetavaks muutmine ja seega ka ruumi kokkuhoid. Koodi funktsioonidena kasutamine suurendab analüüside reprodutseeritavust, kuna funktsioonis olev kood pärineb ühest allikast, mitte ei ole paljude koopiatena igal pool laiali. See muudab pikad koodilõigud hõlpsalt taaskasutatavaks sest lihtsam on kirjutada lühike funktsiooni nimi ja sisestada selle funktsiooni argumendid. Koodi funktsioonidesse kokku surumine vähendab võimalusi lollideks vigadeks, mida te võite teha pikkade koodijuppidega manipuleerides. Seega tasub teil õppida ka oma korduvaid koodiridu funktsioonidena vormistama. Kõige pealt kirjutame natuke koodi. # two apples apples &lt;- 2 # three oranges oranges &lt;- 3 # parentheses around expression assigning result to an object # ensure that result is also printed to R console (inventory &lt;- apples + oranges) ## [1] 5 Ja nüüd pakendame selle tehte funktsiooni add2(). Funktsiooni defineerimiseks kasutame järgmist r ekspressiooni function( arglist ) expr, kus “arglist” on tühi või ühe või rohkema nimega argumenti kujul name=expression; “expr” on R-i ekspressioon st. kood mida see funktsioon käivitab. Funktsiooni viimane evlueeritav koodirida on see, mis tuleb välja selle funktsiooni outputina. All toodud näites on selleks x + y tehte vastus. add2 &lt;- function(x, y) { x + y } Seda koodi jooksutades näeme, et meie funktsioon ilmub R-i Environmenti, kuhu tekib Functions lahter. Seal on näha ka selle funktsiooni kaks argumenti, apples ja oranges. Antud funktsiooni käivitamine annab veateate, sest funktsiooni argumentidel pole väärtusi: ## run function in failsafe mode inventory &lt;- try(add2()) ## when function fails, error message is returned class(inventory) ## [1] &quot;try-error&quot; ## print error message cat(inventory) ## Error in add2() : argument &quot;x&quot; is missing, with no default Andes funktsiooni argumentidele väärtused, saab väljundi: ## run function with proper arguments inventory &lt;- add2(x = apples, y = oranges) ## numeric vector is returned class(inventory) ## [1] &quot;numeric&quot; ## result inventory ## [1] 5 Nüüd midagi kasulikumat! Funktsioon standrardvea arvutamiseks (baas R-s sellist funktsiooni ei ole): sd() funktsioon arvutab standardhälbe. Sellel on kaks argumenti: x and na.rm. Me teame, et SEM=SD/sqrt(N) kus N = length(x) calc_sem &lt;- function(x) { stdev &lt;- sd(x) n &lt;- length(x) stdev / sqrt(n) } x hoiab lihtsalt kohta andmetele, mida me tahame sinna funktsiooni suunata. sd(), sqrt() ja length() on olemasolevad baas R funktsioonid, mille me oma funktsiooni hõlmame. ## create numeric vector numbers &lt;- c(2, 3.4, 54, NA, 3) calc_sem(numbers) ## [1] NA No jah, kui meil on andmetes tundmatu arv (NA) siis on ka tulemuseks tundmatu arv. Sellisel juhul tuleb NA väärtused vektorist enne selle funktsiooni kasutamist välja visata: numbers_filtered &lt;- na.omit(numbers) calc_sem(numbers_filtered) ## [1] 12.8 On ka võimalus funktsiooni sisse kirjutada NA väärtuste käsitlemine. Näiteks, üks võimalus on anda viga ja funktsioon katkestada, et kasutaja saaks ise ühemõtteliselt oma andmetest NA väärtused eemaldada. Teine võimalus on funktsioonis NA-d vaikimisi eemaldada ja anda selle kohta näiteks teade. NA-de vaikimisi eemaldamiseks on hetkel mitu võimalust, kasutame kõigepealt nö. valet lahendust: calc_sem &lt;- function(x) { ## kasutame sd funktsiooni argumenti na.rm stdev &lt;- sd(x, na.rm = TRUE) n &lt;- length(x) stdev / sqrt(n) } calc_sem(numbers) ## [1] 11.45 See annab meile vale tulemuse sest na.rm = TRUE viskab küll NA-d välja meie vektorist aga jätab vektori pikkuse muutmata (length(x) rida). Teeme uue versiooni oma funktsioonist, mis viskab vaikimisi välja puuduvad väärtused, kui need on olemas ja annab siis ka selle kohta hoiatuse. ## x on numbriline vektor calc_sem &lt;- function(x) { ## viskame NA väärtused vektorist välja x &lt;- na.omit(x) ## kui vektoris on NA väärtusi, siis hoiatame kasutajat if(inherits(na.action(x), &quot;omit&quot;)) { warning(&quot;Removed NAs from vector.\\n&quot;) } ## arvutame standardvea kasutades filtreeritud vektorit stdev &lt;- sd(x) n &lt;- length(x) stdev / sqrt(n) } calc_sem(numbers) ## Warning in calc_sem(numbers): Removed NAs from vector. ## [1] 12.8 length(numbers) ## [1] 5 Missugune funktsiooni käitumine valida, sõltub kasutaja vajadusest. Rohkem infot NA käsitlemise funktsioonide kohta saab ?na.omit abifailist. Olgu see õpetuseks, et funktsioonide kirjutamine on järk-järguline protsess ja sellele, et alati saab paremini teha. "],
["tidyverse.html", "7 Tidyverse 7.1 Tidy tabeli struktuur 7.2 dplyr ja selle viis verbi 7.3 Grouped filters 7.4 separate() one column into several 7.5 Faktorid", " 7 Tidyverse Tidyverse on osa R-i ökosüsteemist, kus kehtivad omad reeglid. Tidyverse raamatukogud lähtuvad ühtsest filosoofiast ja töötavad hästi koos. Tidyverse algab andmetabeli struktuurist ja selle funktsioonid võtavad reeglina sisse õige struktuuriga tibble ja väljastavad samuti tibble, mis sobib hästi järgmise tidyverse funktsiooni sisendiks. Seega on tidyverse hästi sobiv läbi torude %&gt;% laskmiseks. Tidyverse-ga sobib hästi kokku ka ggplot2 graafikasüsteem. 7.1 Tidy tabeli struktuur väärtus (value) — ühe mõõtmise tulemus (183 cm) muutuja (variable) — see, mida sa mõõdad (pikkus) või faktor (sex) andmepunkt (observation) — väärtused, mis mõõdeti samal katsetingimusel (1. subjekti pikkus ja kaal 3h ajapunktis) vaatlusühik (unit of measurement) — keda mõõdeti (subjekt nr 1) vaatlusühiku tüüp — inimene, hiir, jt vaatlusühiku tüüp = tabel muutuja = veerg andmepunkt = rida vaatlusühikute koodid on kõik koos ühes veerus Veergude järjekord tabelis on 1. vaatlusühik, 2. faktor, mis annab katse-kontrolli erisuse, 3. kõik see, mida otse ei mõõdetud (sex, batch nr, etc.), 4. numbritega veerud (iga muutuja kohta üks veerg) ## # A tibble: 2 x 6 ## subject drug sex time length weigth ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 exp F 3 168 88 ## 2 2 placebo M 3 176 91 Nii näeb välja tidy tibble. Kõik analüüsil vajalikud parameetrid tuleks siia tabelisse veeru kaupa sisse tuua. Näiteks, kui mõõtmised on sooritatud erinevates keskustes erinevate inimeste poolt kasutades sama ravimi erinevaid preparaate, oleks hea siia veel 3 veergu lisada (center, experimenter, batch). 7.1.1 Tabeli dimensioonide muutmine (pikk ja lai formaat) Väga oluline osa tidyverses töötamisest on tabelite pika ja laia formaadi vahel viimine. See on laias formaadis tabel df, mis ei ole tidy ## # A tibble: 3 x 5 ## subject sex control experiment_1 experiment_2 ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Tim M 23 34 40 ## 2 Ann F 31 38 42 ## 3 Jill F 30 36 44 Kõigepealt pikka formaati. key ja value argumendid on ainult uute veergude nimetamiseks, oluline on 3:ncol(dat) argument, mis ütleb, et “kogu kokku veerud alates 3. veerust”. Alternatiivne viis seda öelda: c(-subject, -sex). dat_lng &lt;- gather(dat, key = experiment, value = value, 3:ncol(dat)) # df_l3&lt;-df %&gt;% gather(experiment, value, 3:ncol(df)) works as well. #df_l4&lt;-df %&gt;% gather(experiment, value, c(-subject, -sex)) works as well dat_lng ## # A tibble: 9 x 4 ## subject sex experiment value ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Tim M control 23 ## 2 Ann F control 31 ## 3 Jill F control 30 ## 4 Tim M experiment_1 34 ## 5 Ann F experiment_1 38 ## 6 Jill F experiment_1 36 ## 7 Tim M experiment_2 40 ## 8 Ann F experiment_2 42 ## 9 Jill F experiment_2 44 Paneme selle tagasi algsesse laia formaati: ?spread spread(dat_lng, key = experiment, value = value) ## # A tibble: 3 x 5 ## subject sex control experiment_1 experiment_2 ## * &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Ann F 31 38 42 ## 2 Jill F 30 36 44 ## 3 Tim M 23 34 40 key viitab pika tabeli veerule, mille väärtustest tulevad laias tabelis uute veergude nimed. value viitab pika tabeli veerule, kust võetakse arvud, mis uues laias tabelis uute veergude vahel laiali jagatakse. 7.1.2 Tibble transpose — read veergudeks ja vastupidi dat &lt;- tibble(a = c(&quot;tim&quot;, &quot;tom&quot;, &quot;jill&quot;), b1 = c(1, 2, 3), b2 = c(4, 5, 6)) dat ## # A tibble: 3 x 3 ## a b1 b2 ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 tim 1 4 ## 2 tom 2 5 ## 3 jill 3 6 Me kasutame selleks maatriksarvutuse funktsiooni t() — transpose. See võtab sisse ainult numbrilisi veerge, seega anname talle ette df miinus 1. veerg, mille sisu me konverteerime uue tablei veerunimedeks. dat1 &lt;- t(dat[,-1]) colnames(dat1) &lt;- dat$a dat1 ## tim tom jill ## b1 1 2 3 ## b2 4 5 6 7.2 dplyr ja selle viis verbi Need tuleb teil omale pähe ajada sest nende 5 verbiga (pluss gather ja spread) saab lihtsalt teha 90% andmeväänamisest, mida teil elus vaja läheb. NB! Check the data wrangling cheatsheet and dplyr help for further details. dplyr laetakse koos tidyverse-ga automaatselt teie workspace. 7.2.1 select() columns select() selects, renames, and re-orders columns. Select columns from sex to value: iris select(iris, Petal.Length:Species) select(iris, -(Petal.Length:Species)) #selects everything, except those cols To select 3 columns and rename subject to SUBJ and put liik as the 1st col: select(iris, liik = Species, Sepal.Length, Sepal.Width) %&gt;% dplyr::as_data_frame() ## # A tibble: 150 x 3 ## liik Sepal.Length Sepal.Width ## &lt;fctr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 setosa 5.1 3.5 ## 2 setosa 4.9 3.0 ## 3 setosa 4.7 3.2 ## 4 setosa 4.6 3.1 ## 5 setosa 5.0 3.6 ## 6 setosa 5.4 3.9 ## 7 setosa 4.6 3.4 ## 8 setosa 5.0 3.4 ## 9 setosa 4.4 2.9 ## 10 setosa 4.9 3.1 ## # ... with 140 more rows To select all cols, except sex and value, and rename the subject col: select(iris, -Sepal.Length, -Sepal.Width, liik = Species) helper functions you can use within select(): starts_with(&quot;abc&quot;): matches names that begin with “abc.” ends_with(&quot;xyz&quot;): matches names that end with “xyz.” contains(&quot;ijk&quot;): matches names that contain “ijk.” matches(&quot;(.)\\\\1&quot;): selects variables that match a regular expression. This one matches any variables that contain repeated characters. num_range(&quot;x&quot;, 1:3) matches x1, x2 and x3. iris &lt;- as_tibble(iris) select(iris, starts_with(&quot;Petal&quot;)) ## # A tibble: 150 x 2 ## Petal.Length Petal.Width ## &lt;dbl&gt; &lt;dbl&gt; ## 1 1.4 0.2 ## 2 1.4 0.2 ## 3 1.3 0.2 ## 4 1.5 0.2 ## 5 1.4 0.2 ## 6 1.7 0.4 ## 7 1.4 0.3 ## 8 1.5 0.2 ## 9 1.4 0.2 ## 10 1.5 0.1 ## # ... with 140 more rows select(iris, ends_with(&quot;Width&quot;)) ## # A tibble: 150 x 2 ## Sepal.Width Petal.Width ## &lt;dbl&gt; &lt;dbl&gt; ## 1 3.5 0.2 ## 2 3.0 0.2 ## 3 3.2 0.2 ## 4 3.1 0.2 ## 5 3.6 0.2 ## 6 3.9 0.4 ## 7 3.4 0.3 ## 8 3.4 0.2 ## 9 2.9 0.2 ## 10 3.1 0.1 ## # ... with 140 more rows # Move Species variable to the front select(iris, Species, everything()) ## # A tibble: 150 x 5 ## Species Sepal.Length Sepal.Width Petal.Length ## &lt;fctr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 setosa 5.1 3.5 1.4 ## 2 setosa 4.9 3.0 1.4 ## 3 setosa 4.7 3.2 1.3 ## 4 setosa 4.6 3.1 1.5 ## 5 setosa 5.0 3.6 1.4 ## 6 setosa 5.4 3.9 1.7 ## 7 setosa 4.6 3.4 1.4 ## 8 setosa 5.0 3.4 1.5 ## 9 setosa 4.4 2.9 1.4 ## 10 setosa 4.9 3.1 1.5 ## # ... with 140 more rows, and 1 more variables: ## # Petal.Width &lt;dbl&gt; dat &lt;- as.data.frame(matrix(runif(100), nrow = 10)) dat &lt;- tbl_df(dat[c(3, 4, 7, 1, 9, 8, 5, 2, 6, 10)]) select(dat, V9:V6) ## # A tibble: 10 x 5 ## V9 V8 V5 V2 V6 ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0.51502 0.7071 0.91824 0.3629 0.23244 ## 2 0.40062 0.7479 0.36441 0.8079 0.77043 ## 3 0.57236 0.3280 0.24827 0.4356 0.19992 ## 4 0.39159 0.4651 0.39239 0.4262 0.34117 ## 5 0.81634 0.6054 0.49056 0.1186 0.87146 ## 6 0.21121 0.4576 0.43537 0.5009 0.01517 ## 7 0.60405 0.5875 0.02298 0.1704 0.96598 ## 8 0.86714 0.2944 0.02522 0.2539 0.67663 ## 9 0.04453 0.9104 0.19554 0.1903 0.88319 ## 10 0.03943 0.4583 0.16339 0.1815 0.43436 select(dat, num_range(&quot;V&quot;, 9:6)) ## # A tibble: 10 x 4 ## V9 V8 V7 V6 ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0.51502 0.7071 0.5982 0.23244 ## 2 0.40062 0.7479 0.4220 0.77043 ## 3 0.57236 0.3280 0.2635 0.19992 ## 4 0.39159 0.4651 0.4843 0.34117 ## 5 0.81634 0.6054 0.6893 0.87146 ## 6 0.21121 0.4576 0.8237 0.01517 ## 7 0.60405 0.5875 0.6368 0.96598 ## 8 0.86714 0.2944 0.2862 0.67663 ## 9 0.04453 0.9104 0.2862 0.88319 ## 10 0.03943 0.4583 0.3451 0.43436 # Drop variables with - select(iris, -starts_with(&quot;Petal&quot;)) ## # A tibble: 150 x 3 ## Sepal.Length Sepal.Width Species ## &lt;dbl&gt; &lt;dbl&gt; &lt;fctr&gt; ## 1 5.1 3.5 setosa ## 2 4.9 3.0 setosa ## 3 4.7 3.2 setosa ## 4 4.6 3.1 setosa ## 5 5.0 3.6 setosa ## 6 5.4 3.9 setosa ## 7 4.6 3.4 setosa ## 8 5.0 3.4 setosa ## 9 4.4 2.9 setosa ## 10 4.9 3.1 setosa ## # ... with 140 more rows # Renaming ----------------------------------------- # select() keeps only the variables you specify # rename() keeps all variables rename(iris, petal_length = Petal.Length) ## # A tibble: 150 x 5 ## Sepal.Length Sepal.Width petal_length Petal.Width ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 5.1 3.5 1.4 0.2 ## 2 4.9 3.0 1.4 0.2 ## 3 4.7 3.2 1.3 0.2 ## 4 4.6 3.1 1.5 0.2 ## 5 5.0 3.6 1.4 0.2 ## 6 5.4 3.9 1.7 0.4 ## 7 4.6 3.4 1.4 0.3 ## 8 5.0 3.4 1.5 0.2 ## 9 4.4 2.9 1.4 0.2 ## 10 4.9 3.1 1.5 0.1 ## # ... with 140 more rows, and 1 more variables: ## # Species &lt;fctr&gt; 7.2.2 filter() rows Keep rows in Iris that have Species level “setosa” and Sepal.Length value &lt;4.5. filter(iris, Species==&quot;setosa&quot; &amp; Sepal.Length &lt; 4.5) ## # A tibble: 4 x 5 ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 4.4 2.9 1.4 0.2 ## 2 4.3 3.0 1.1 0.1 ## 3 4.4 3.0 1.3 0.2 ## 4 4.4 3.2 1.3 0.2 ## # ... with 1 more variables: Species &lt;fctr&gt; Keep rows in Iris that have Species level “setosa” or Sepal.Length value &lt;4.5. filter(iris, Species==&quot;setosa&quot; | Sepal.Length &lt; 4.5) ## # A tibble: 50 x 5 ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 5.1 3.5 1.4 0.2 ## 2 4.9 3.0 1.4 0.2 ## 3 4.7 3.2 1.3 0.2 ## 4 4.6 3.1 1.5 0.2 ## 5 5.0 3.6 1.4 0.2 ## 6 5.4 3.9 1.7 0.4 ## 7 4.6 3.4 1.4 0.3 ## 8 5.0 3.4 1.5 0.2 ## 9 4.4 2.9 1.4 0.2 ## 10 4.9 3.1 1.5 0.1 ## # ... with 40 more rows, and 1 more variables: ## # Species &lt;fctr&gt; Keep rows in Iris that have Species level “not setosa” or Sepal.Length value &lt;4.5. filter(iris, Species !=&quot;setosa&quot; | Sepal.Length &lt; 4.5) ## # A tibble: 104 x 5 ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 4.4 2.9 1.4 0.2 ## 2 4.3 3.0 1.1 0.1 ## 3 4.4 3.0 1.3 0.2 ## 4 4.4 3.2 1.3 0.2 ## 5 7.0 3.2 4.7 1.4 ## 6 6.4 3.2 4.5 1.5 ## 7 6.9 3.1 4.9 1.5 ## 8 5.5 2.3 4.0 1.3 ## 9 6.5 2.8 4.6 1.5 ## 10 5.7 2.8 4.5 1.3 ## # ... with 94 more rows, and 1 more variables: ## # Species &lt;fctr&gt; Kui tahame samast veerust filtreerida “või” ehk “|” abil mitu väärtust, on meil valida kahe samaväärse variandi vahel (tegelikult töötab 2. variant ka ühe väärtuse korral) filter(iris, Species ==&quot;setosa&quot; | Species ==&quot;versicolor&quot;) filter(iris, Species %in% c(&quot;setosa&quot;, &quot;versicolor&quot;) ) Nagu näha, 2. variant on oluliselt lühem. Filtering with regular expression: we keep the rows where subject starts with the letter “T” library(stringr) filter(iris, str_detect(Species, &quot;^v&quot;)) ## # A tibble: 100 x 5 ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 7.0 3.2 4.7 1.4 ## 2 6.4 3.2 4.5 1.5 ## 3 6.9 3.1 4.9 1.5 ## 4 5.5 2.3 4.0 1.3 ## 5 6.5 2.8 4.6 1.5 ## 6 5.7 2.8 4.5 1.3 ## 7 6.3 3.3 4.7 1.6 ## 8 4.9 2.4 3.3 1.0 ## 9 6.6 2.9 4.6 1.3 ## 10 5.2 2.7 3.9 1.4 ## # ... with 90 more rows, and 1 more variables: ## # Species &lt;fctr&gt; As you can see there are endless vistas here, open for a regular expression fanatic. I wish I was one! remove NAs with filter() filter(flights, !is.na(dep_delay), !is.na(arr_delay)) 7.2.3 summarise() Many rows summarised to a single value summarise(iris, MEAN = mean(Sepal.Length), SD = sd(Sepal.Length), N = n(), n_species = n_distinct(Species)) ## # A tibble: 1 x 4 ## MEAN SD N n_species ## &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 5.843 0.8281 150 3 n() loeb üles, mitu väärtust läks selle summary statistic-u arvutusse, n_distinct() loeb üles, mitu unikaalset väärtust läks samasse arvutusse. summarise on kasulikum, kui teda kasutada koos järgmise verbi, group_by-ga. 7.2.4 group_by() group_by() groups values for summarising or mutating- When we summarise by sex we will get two values for each summary statistic: for males and females. Aint that sexy?! iris_grouped &lt;- group_by(iris, Species) summarise(iris_grouped, MEAN = mean(Sepal.Length), SD = sd(Sepal.Length), N = n(), n_species = n_distinct(Species)) ## # A tibble: 3 x 5 ## Species MEAN SD N n_species ## &lt;fctr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 setosa 5.006 0.3525 50 1 ## 2 versicolor 5.936 0.5162 50 1 ## 3 virginica 6.588 0.6359 50 1 summarise() argumendid on indentsed eelmise näitega aga tulemus ei ole. Siin me rakendame summarise verbi mitte kogu tabelile, vaid 3-le virtuaalsele tabelile, mis on saadud algsest tabelist. group_by()-le saab anda järjest mitu grupeerivat muutujat. Siis ta grupeerib kõigepealt neist esimese järgi, seejärel lõõb saadud grupid omakorda lahku teise argumendi järgi ja nii edasi kuni teie poolt antud argumendid otsa saavad. Now we group previously generated dat_lng data frame first by sex and then inside each group again by experiment. This is getting complicated … dat_lng ## # A tibble: 9 x 4 ## subject sex experiment value ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Tim M control 23 ## 2 Ann F control 31 ## 3 Jill F control 30 ## 4 Tim M experiment_1 34 ## 5 Ann F experiment_1 38 ## 6 Jill F experiment_1 36 ## 7 Tim M experiment_2 40 ## 8 Ann F experiment_2 42 ## 9 Jill F experiment_2 44 group_by(dat_lng, sex, experiment) %&gt;% summarise(MEAN = mean(value), SD = sd(value), N = n(), n_sex = n_distinct(sex)) ## # A tibble: 6 x 6 ## # Groups: sex [?] ## sex experiment MEAN SD N n_sex ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 F control 30.5 0.7071 2 1 ## 2 F experiment_1 37.0 1.4142 2 1 ## 3 F experiment_2 43.0 1.4142 2 1 ## 4 M control 23.0 NA 1 1 ## 5 M experiment_1 34.0 NA 1 1 ## 6 M experiment_2 40.0 NA 1 1 Now we group first by sex and then by variable. Spot the difference! group_by(dat_lng, experiment, sex) %&gt;% summarise(MEAN = mean(value), SD = sd(value), N = n(), n_sex = n_distinct(sex)) ## # A tibble: 6 x 6 ## # Groups: experiment [?] ## experiment sex MEAN SD N n_sex ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 control F 30.5 0.7071 2 1 ## 2 control M 23.0 NA 1 1 ## 3 experiment_1 F 37.0 1.4142 2 1 ## 4 experiment_1 M 34.0 NA 1 1 ## 5 experiment_2 F 43.0 1.4142 2 1 ## 6 experiment_2 M 40.0 NA 1 1 pro tip if you want to summarise and then display the summary values as new column(s), which are added to the original non-shrunk df, use mutate() instead of summarise(). mutate(iris_grouped, MEAN = mean(Sepal.Length), SD = sd(Sepal.Length)) ## # A tibble: 150 x 7 ## # Groups: Species [3] ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 5.1 3.5 1.4 0.2 ## 2 4.9 3.0 1.4 0.2 ## 3 4.7 3.2 1.3 0.2 ## 4 4.6 3.1 1.5 0.2 ## 5 5.0 3.6 1.4 0.2 ## 6 5.4 3.9 1.7 0.4 ## 7 4.6 3.4 1.4 0.3 ## 8 5.0 3.4 1.5 0.2 ## 9 4.4 2.9 1.4 0.2 ## 10 4.9 3.1 1.5 0.1 ## # ... with 140 more rows, and 3 more variables: ## # Species &lt;fctr&gt;, MEAN &lt;dbl&gt;, SD &lt;dbl&gt; Anna igast grupist 3 kõrgeimat väärtust ja 2 madalaimat väärtust. Samad numbrid erinevates ridades antakse kõik - selle pärast on meil tabelis rohkem ridu. top_n(iris_grouped, 3, Sepal.Length) top_n(iris_grouped, -2, Sepal.Length) 7.2.5 mutate() Mutate põhikasutus on siiski uute veergude tekitamine, mis võtavad endale inputi rea kaupa. Seega tabeli ridade arv ei muutu. If in your tibble called ‘df’ you have a column called ‘value’, you can create a new log2 transformed value value column called log_value by df %&gt;% mutate(log_value = log2(value)). Or you can create a new column where a constant is substracted from the value column: df %&gt;% mutate(centered_value = value - mean(value) ). Here the mean value is substracted from each individual value. Mutate adds new columns (and transmute() creates new columns while losing the previous columns) Here we firstly create a new column, which contains log-transformed values from the value column, and name it log_value. mutate(dat_lng, log_value = log(value)) ## # A tibble: 9 x 5 ## subject sex experiment value log_value ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Tim M control 23 3.135 ## 2 Ann F control 31 3.434 ## 3 Jill F control 30 3.401 ## 4 Tim M experiment_1 34 3.526 ## 5 Ann F experiment_1 38 3.638 ## 6 Jill F experiment_1 36 3.584 ## 7 Tim M experiment_2 40 3.689 ## 8 Ann F experiment_2 42 3.738 ## 9 Jill F experiment_2 44 3.784 The same with transmute: note the dropping of some of the original cols, keeping the original subject col and renaming the sex col. transmute(dat_lng, subject, gender = sex, log_value = log(value)) ## # A tibble: 9 x 3 ## subject gender log_value ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Tim M 3.135 ## 2 Ann F 3.434 ## 3 Jill F 3.401 ## 4 Tim M 3.526 ## 5 Ann F 3.638 ## 6 Jill F 3.584 ## 7 Tim M 3.689 ## 8 Ann F 3.738 ## 9 Jill F 3.784 flights_sml &lt;- select(flights, year:day, ends_with(&quot;delay&quot;), distance, air_time) %&gt;% mutate(gain = arr_delay - dep_delay, hours = air_time / 60, gain_per_hour = gain / hours) mutate_all(), mutate_if() and mutate_at() and the three variants of transmute() (transmute_all(), transmute_if(), transmute_at()) make it easy to apply a transformation to a selection of variables. See help. Here we first group and then mutate. Note that now, instead of a single constant, we divide by as many different constant as there are discrete factor levels in the sex variable (two, in our case): group_by(dat_lng, sex) %&gt;% mutate(norm_value = value / mean(value), n2_val = value / sd(value)) ## # A tibble: 9 x 6 ## # Groups: sex [2] ## subject sex experiment value norm_value n2_val ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Tim M control 23 0.7113 2.668 ## 2 Ann F control 31 0.8416 5.466 ## 3 Jill F control 30 0.8145 5.290 ## 4 Tim M experiment_1 34 1.0515 3.944 ## 5 Ann F experiment_1 38 1.0317 6.700 ## 6 Jill F experiment_1 36 0.9774 6.347 ## 7 Tim M experiment_2 40 1.2371 4.639 ## 8 Ann F experiment_2 42 1.1403 7.405 ## 9 Jill F experiment_2 44 1.1946 7.758 Compare with a “straight” mutate to see the difference in values. mutate(dat_lng, norm_value = value / mean(value), n2_val = value / sd(value)) ## # A tibble: 9 x 6 ## subject sex experiment value norm_value n2_val ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Tim M control 23 0.6509 3.477 ## 2 Ann F control 31 0.8774 4.687 ## 3 Jill F control 30 0.8491 4.536 ## 4 Tim M experiment_1 34 0.9623 5.140 ## 5 Ann F experiment_1 38 1.0755 5.745 ## 6 Jill F experiment_1 36 1.0189 5.443 ## 7 Tim M experiment_2 40 1.1321 6.047 ## 8 Ann F experiment_2 42 1.1887 6.350 ## 9 Jill F experiment_2 44 1.2453 6.652 7.3 Grouped filters Keep all groups bigger than a threshold: popular_dests &lt;- flights %&gt;% group_by(dest) %&gt;% filter(n() &gt; 365) If you need to remove grouping, and return to operations on ungrouped data, use ungroup(). ungroup(dat) str_replace_all() helps to deal with unruly labelling inside columns containing strings The idea is to find a pattern in a collection of strings and replace it with something else. String == character vector. To find and replace we use str_replace_all(), whose base R analogue is gsub(). library(stringr) (bad.df &lt;- tibble(time = c(&quot;t0&quot;, &quot;t1&quot;, &quot;t12&quot;), value = c(2, 4, 9))) ## # A tibble: 3 x 2 ## time value ## &lt;chr&gt; &lt;dbl&gt; ## 1 t0 2 ## 2 t1 4 ## 3 t12 9 get_numeric &lt;- function(x, ...) as.numeric(str_replace_all(x, ...)) (bad.df &lt;- mutate_at(bad.df, &quot;time&quot;, get_numeric, pattern = &quot;t&quot;, replacement = &quot;&quot;)) ## # A tibble: 3 x 2 ## time value ## &lt;dbl&gt; &lt;dbl&gt; ## 1 0 2 ## 2 1 4 ## 3 12 9 now we have a numeric time column, which can be used in plotting. or library(readr) (bad.df &lt;- tibble(time = c(&quot;t0&quot;, &quot;t1&quot;, &quot;t12&quot;), value = c(2, 4, 9))) ## # A tibble: 3 x 2 ## time value ## &lt;chr&gt; &lt;dbl&gt; ## 1 t0 2 ## 2 t1 4 ## 3 t12 9 mutate_at(bad.df, &quot;time&quot;, parse_number) ## # A tibble: 3 x 2 ## time value ## &lt;dbl&gt; &lt;dbl&gt; ## 1 0 2 ## 2 1 4 ## 3 12 9 Here we did the same thing more elegantly by directly parsing numbers from a character string. 7.4 separate() one column into several Siin on veel üks verb, mida aeg-ajalt kõigil vaja läheb. separate() võtab ühe veeru sisu (mis peab olema character string) ning jagab selle laiali mitme uue veeru vahel. Kui teda kasutada vormis separate(df, old_Column, into=c(&quot;new_col1&quot;, &quot;new_col2&quot;, &quot;ja_nii_edasi&quot;)) siis püüab programm ise ära arvata, kustkohalt veeru sisu hakkida (tühikud, komad, semikoolonid, koolonid jne). Aga te võite eksplitsiitselt ette anda separaatori sep = “”. sep = 2 tähendab “peale 2. tähemärki”. sep = -6 tähendab “enne tagantpoolt 6. tähemärki” (dat &lt;- tibble(country = c(&quot;Albania&quot;), disease.cases = c(&quot;80/1000&quot;))) ## # A tibble: 1 x 2 ## country disease.cases ## &lt;chr&gt; &lt;chr&gt; ## 1 Albania 80/1000 (df.sep &lt;- dat %&gt;% separate(disease.cases, into=c(&quot;cases&quot;, &quot;thousand&quot;))) ## # A tibble: 1 x 3 ## country cases thousand ## * &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Albania 80 1000 (df.sep &lt;- dat %&gt;% separate(disease.cases, into=c(&quot;cases&quot;, &quot;thousand&quot;), sep = &quot;/&quot;)) ## # A tibble: 1 x 3 ## country cases thousand ## * &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Albania 80 1000 (df.sep &lt;- dat %&gt;% separate(disease.cases, into=c(&quot;cases&quot;, &quot;thousand&quot;), sep = 2)) ## # A tibble: 1 x 3 ## country cases thousand ## * &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Albania 80 /1000 (df.sep &lt;- dat %&gt;% separate(disease.cases, into=c(&quot;cases&quot;, &quot;thousand&quot;), sep = -6)) ## # A tibble: 1 x 3 ## country cases thousand ## * &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Albania 80 /1000 (dat &lt;- tibble(index = c(1, 2), taxon = c(&quot;Procaryota; Bacteria; Alpha-Proteobacteria; Escharichia&quot;, &quot;Eukaryota; Chordata&quot;))) ## # A tibble: 2 x 2 ## index ## &lt;dbl&gt; ## 1 1 ## 2 2 ## # ... with 1 more variables: taxon &lt;chr&gt; (d1 &lt;- dat %&gt;% separate(taxon, c(&#39;riik&#39;, &#39;hmk&#39;, &quot;klass&quot;, &quot;perekond&quot;), sep = &#39;; &#39;, extra = &quot;merge&quot;, fill = &quot;right&quot;)) ## # A tibble: 2 x 5 ## index riik hmk klass ## * &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 Procaryota Bacteria Alpha-Proteobacteria ## 2 2 Eukaryota Chordata &lt;NA&gt; ## # ... with 1 more variables: perekond &lt;chr&gt; # some special cases: (dat &lt;- tibble(index = c(1, 2), taxon = c(&quot;Prokaryota || Bacteria || Alpha-Proteobacteria || Escharichia&quot;, &quot;Eukaryota || Chordata&quot;))) ## # A tibble: 2 x 2 ## index ## &lt;dbl&gt; ## 1 1 ## 2 2 ## # ... with 1 more variables: taxon &lt;chr&gt; (d1 &lt;- dat %&gt;% separate(taxon, c(&quot;riik&quot;, &quot;hmk&quot;, &quot;klass&quot;, &quot;perekond&quot;), sep = &quot;\\\\|\\\\|&quot;, extra = &quot;merge&quot;, fill = &quot;right&quot;)) ## # A tibble: 2 x 5 ## index riik hmk klass ## * &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 Prokaryota Bacteria Alpha-Proteobacteria ## 2 2 Eukaryota Chordata &lt;NA&gt; ## # ... with 1 more variables: perekond &lt;chr&gt; dat &lt;- tibble(index = c(1, 2), taxon = c(&quot;Prokaryota.Bacteria.Alpha-Proteobacteria.Escharichia&quot;, &quot;Eukaryota.Chordata&quot;)) (d1 &lt;- dat %&gt;% separate(taxon, c(&#39;riik&#39;, &#39;hmk&#39;, &quot;klass&quot;, &quot;perekond&quot;), sep = &#39;[.]&#39;, extra = &quot;merge&quot;, fill = &quot;right&quot;)) ## # A tibble: 2 x 5 ## index riik hmk klass ## * &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 Prokaryota Bacteria Alpha-Proteobacteria ## 2 2 Eukaryota Chordata &lt;NA&gt; ## # ... with 1 more variables: perekond &lt;chr&gt; (dat &lt;- tibble(index = c(1,2), taxon = c(&quot;Prokaryota.Bacteria,Alpha-Proteobacteria.Escharichia&quot;, &quot;Eukaryota.Chordata&quot;))) ## # A tibble: 2 x 2 ## index ## &lt;dbl&gt; ## 1 1 ## 2 2 ## # ... with 1 more variables: taxon &lt;chr&gt; (d1 &lt;- dat %&gt;% separate(taxon, c(&#39;riik&#39;, &#39;hmk&#39;, &quot;klass&quot;, &quot;perekond&quot;), sep = &#39;[,\\\\.]&#39;, extra = &quot;merge&quot;, fill = &quot;right&quot;)) ## # A tibble: 2 x 5 ## index riik hmk klass ## * &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 Prokaryota Bacteria Alpha-Proteobacteria ## 2 2 Eukaryota Chordata &lt;NA&gt; ## # ... with 1 more variables: perekond &lt;chr&gt; The companion FUN to separate is unite() - see help. 7.5 Faktorid Faktor on andmetüüp, mis oli ajalooliselt tähtsam kui ta praegu on. Sageli saame oma asja ära ajada character vectori andmetüübiga ja ei vaja faktorit. Aga siiski läheb faktoreid aeg-ajalt kõigil vaja. Faktorite abil töötame kategooriliste muutujatega, millel on fikseeritud hulk võimalikke väärtusi, mida me kõiki teame. Faktori väärtusi kutsutakse “tasemeteks” (levels). Näiteks: muutuja sex on 2 tasemega faktor (M, F) NB! Faktoriks muutes saame character vectori liikmete järjekorra muuta mitte-tähestikuliseks Me kasutame faktoritega töötamisel forcats paketti. Kõigepealt loome character vectori x1 nelja kuu nime ingliskeelse lühendiga. library(forcats) x1 &lt;- c(&quot;Dec&quot;, &quot;Apr&quot;, &quot;Jan&quot;, &quot;Mar&quot;) Nüüd kujutlege, et vektor x1 sisaldab 10 000 elementi. Seda vektorit on raske sorteerida, ja trükivead on ka raskesti leitavad. Mõlema probleemi vastu aitab, kui me konverteerime x1-e faktoriks. Selleks, et luua uus faktor, peaks kõigepealt üles lugema selle faktori kõik võimalikud tasemed: Nüüd loome uue faktori ehk muudame x1 character vektori y1 factor vektoriks. Erinevalt x1-st seostub iga y1 väärtusega faktori tase. Kui algses vektoris on mõni element, millele ei vasta näiteks trükivea tõttu ühtegi faktori taset, siis see element muudetakse NA-ks. Proovige see ise järele, viies trükivea sisse x1-e. y1 &lt;- factor(x1, levels = month.abb) y1 ## [1] Dec Apr Jan Mar ## 12 Levels: Jan Feb Mar Apr May Jun Jul Aug Sep ... Dec NB! month.abb on R objekt mis sisaldab kuude ingliskeelseid lühendeid. Kui sa faktorile tasemeid ette ei anna, siis need tekivad andmetest automaatselt ja tähestikulises järjekorras. Kui sa tahad, et faktori tasemed oleks samas järjekorras kui selle taseme esmakordne ilmumine teie andmetes siis: f2 &lt;- factor(x1) %&gt;% fct_inorder() f2 ## [1] Dec Apr Jan Mar ## Levels: Dec Apr Jan Mar levels() annab faktori tasemed ja nende järjekorra levels(f2) ## [1] &quot;Dec&quot; &quot;Apr&quot; &quot;Jan&quot; &quot;Mar&quot; Kui faktorid on tibbles oma veeruna, siis saab nende tasemed count() kasutades: gss_cat #tibble, mille veerg &quot;race&quot; on faktor. ## # A tibble: 21,483 x 9 ## year marital age race rincome ## &lt;int&gt; &lt;fctr&gt; &lt;int&gt; &lt;fctr&gt; &lt;fctr&gt; ## 1 2000 Never married 26 White $8000 to 9999 ## 2 2000 Divorced 48 White $8000 to 9999 ## 3 2000 Widowed 67 White Not applicable ## 4 2000 Never married 39 White Not applicable ## 5 2000 Divorced 25 White Not applicable ## 6 2000 Married 25 White $20000 - 24999 ## 7 2000 Never married 36 White $25000 or more ## 8 2000 Divorced 44 White $7000 to 7999 ## 9 2000 Married 44 White $25000 or more ## 10 2000 Married 47 White $25000 or more ## # ... with 21,473 more rows, and 4 more variables: ## # partyid &lt;fctr&gt;, relig &lt;fctr&gt;, denom &lt;fctr&gt;, ## # tvhours &lt;int&gt; gss_cat %&gt;% count(race) ## # A tibble: 3 x 2 ## race n ## &lt;fctr&gt; &lt;int&gt; ## 1 Other 1959 ## 2 Black 3129 ## 3 White 16395 Nii saame ka teada, mitu korda iga faktori tase selles tabelis esineb. 7.5.1 fct_recode() rekodeerib faktori tasemed gss_cat %&gt;% count(partyid) ## # A tibble: 10 x 2 ## partyid n ## &lt;fctr&gt; &lt;int&gt; ## 1 No answer 154 ## 2 Don&#39;t know 1 ## 3 Other party 393 ## 4 Strong republican 2314 ## 5 Not str republican 3032 ## 6 Ind,near rep 1791 ## 7 Independent 4119 ## 8 Ind,near dem 2499 ## 9 Not str democrat 3690 ## 10 Strong democrat 3490 gss_cat %&gt;% mutate(partyid = fct_recode(partyid, &quot;Republican, strong&quot; = &quot;Strong republican&quot;, &quot;Republican, weak&quot; = &quot;Not str republican&quot;, &quot;Independent, near rep&quot; = &quot;Ind,near rep&quot;, &quot;Independent, near dem&quot; = &quot;Ind,near dem&quot;, &quot;Democrat, weak&quot; = &quot;Not str democrat&quot;, &quot;Democrat, strong&quot; = &quot;Strong democrat&quot;, &quot;Other&quot; = &quot;No answer&quot;, &quot;Other&quot; = &quot;Don&#39;t know&quot;, &quot;Other&quot; = &quot;Other party&quot; )) %&gt;% count(partyid) ## # A tibble: 8 x 2 ## partyid n ## &lt;fctr&gt; &lt;int&gt; ## 1 Other 548 ## 2 Republican, strong 2314 ## 3 Republican, weak 3032 ## 4 Independent, near rep 1791 ## 5 Independent 4119 ## 6 Independent, near dem 2499 ## 7 Democrat, weak 3690 ## 8 Democrat, strong 3490 fct_recode() ei puuduta neid tasemeid, mida selle argumendis ei mainita. Lisaks saab mitu vana taset muuta üheks uueks tasemeks. 7.5.2 fct_collapse() annab argumenti sisse vanade tasemete vektori, et teha vähem uusi tasemeid. gss_cat %&gt;% mutate(partyid = fct_collapse(partyid, other = c(&quot;No answer&quot;, &quot;Don&#39;t know&quot;, &quot;Other party&quot;), rep = c(&quot;Strong republican&quot;, &quot;Not str republican&quot;), ind = c(&quot;Ind,near rep&quot;, &quot;Independent&quot;, &quot;Ind,near dem&quot;), dem = c(&quot;Not str democrat&quot;, &quot;Strong democrat&quot;) )) %&gt;% count(partyid) 7.5.3 fct_lump() lööb kokku kõik vähem arv kordi esinevad tasemed. n parameeter ütleb, mitu algset taset tuleb alles jätta: gss_cat %&gt;% mutate(relig = fct_lump(relig, n = 5)) %&gt;% count(relig, sort = TRUE) %&gt;% print() ## # A tibble: 6 x 2 ## relig n ## &lt;fctr&gt; &lt;int&gt; ## 1 Protestant 10846 ## 2 Catholic 5124 ## 3 None 3523 ## 4 Other 913 ## 5 Christian 689 ## 6 Jewish 388 7.5.4 Rekodeerime pideva muutuja faktoriks cut() jagab meie muutuja väärtused intervallidesse ja annab igale intervallile faktori taseme. cut(x, breaks, labels = NULL, ordered_result = FALSE, ...) breaks - either a numeric vector of two or more unique cut points or a single number &gt;1, giving the number of intervals into which x is to be cut. labels - labels for the levels of the resulting category. ordered_result - logical: should the result be an ordered factor? z &lt;- 1:10 z1 &lt;- cut(z, breaks = c(0, 3, 6, 10), labels = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)) z1 ## [1] A A A B B B C C C C ## Levels: A B C #Note that to include 1 in level “A” you need to start the first cut &lt;1, while at the right side 3 is included in the 1st cut (in factor level “A”) z2 &lt;- cut(z, breaks = 3, labels = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)) z2 ## [1] A A A A B B B C C C ## Levels: A B C car::recode aitab rekodeerida library(car) ## ## Attaching package: &#39;car&#39; ## The following object is masked from &#39;package:purrr&#39;: ## ## some ## The following object is masked from &#39;package:dplyr&#39;: ## ## recode x &lt;- rep(1:3, 3) x ## [1] 1 2 3 1 2 3 1 2 3 recode(x, &quot;c(1,2) = &#39;A&#39;; else = &#39;B&#39;&quot;) ## [1] &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;A&quot; &quot;A&quot; &quot;B&quot; recode(x, &quot;c(1,2) = NA&quot;) ## [1] NA NA 3 NA NA 3 NA NA 3 recode(x, &quot;1:2 = &#39;A&#39;; 3 = &#39;B&#39;&quot;) ## [1] &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;A&quot; &quot;A&quot; &quot;B&quot; 7.5.5 Muudame faktori tasemete järjekorda joonisel ## summeerime andmed gsscat_sum &lt;- group_by(gss_cat, relig) %&gt;% summarise(age = mean(age, na.rm = TRUE), tvhours = mean(tvhours, na.rm = TRUE), n = n()) ## joonistame graafiku p &lt;- ggplot(gsscat_sum, aes(tvhours, fct_reorder(relig, tvhours))) + geom_point() p 7.5.6 fct_relevel() tõstab joonisel osad tasemed teistest ettepoole Argumendid on faktor f ja need tasemed (jutumärkides), mida sa tahad tõsta. ## täiendame eelmist graafikut ümberkorraldatud andmetega p + aes(tvhours, fct_relevel(relig, &quot;None&quot;, &quot;Don&#39;t know&quot;)) 7.5.7 Joontega plotil saab fct_reorder2() abil assotseerida y väärtused suurimate x väärtustega See muudab ploti paremini jälgitavaks: ## summeerime andmed gsscat_sum &lt;- filter(gss_cat, !is.na(age)) %&gt;% group_by(age, marital) %&gt;% mutate(N=n()) ## paneme andmed graafikule ggplot(gsscat_sum, aes(age, N, colour = fct_reorder2(marital, age, N))) + geom_line() + labs(colour = &quot;marital&quot;) 7.5.8 Tulpdiagrammide korral kasuta fct_infreq() Loeme kokku erineva perekondliku staatusega isikud ja paneme need andmed tulpdiagrammi grupi suurusele vastupidises järjekorras st. väiksemad grupid tulevad enne. mutate(gss_cat, marital = fct_infreq(marital) %&gt;% fct_rev()) %&gt;% ggplot(aes(marital)) + geom_bar() "],
["bibliograafia.html", "Bibliograafia", " Bibliograafia "]
]
