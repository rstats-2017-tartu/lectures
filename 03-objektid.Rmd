
```{r, message=FALSE}
library(tidyverse)
library(VIM)
library(readxl)
library(skimr)
```


# R-i tööpõhimõte

Iga kord, kui avate R studio, alustate R-i sessiooni, mis seisneb funktsioonide (väikeste programmijuppide) rakendamises andmetele eesmärgiga muuta tabelite struktuuri, transformeerida andmeid, genereerida jooniseid ja/või arvutada statistikuid. Kõik see toimub R-i töökeskkonnas. Tulemusi saab töökeskkonnast eksportida arvuti kõvakettale näiteks .pdf (joonised) või .csv (tabelid) formaadis. Teie sessiooni põhiline tulemus ei ole siiski eksporditavad asjad, vaid R-i kood (script), mida jooksutades on võimalik korrataval viisil algset andmetabelit manipuleerida. Kõik, mida te töökeskonnas teete, kajastub koodis ja on korratav.

R-i sessioon näeb üldjoontes välja niimoodi:


 (1) Andmed ja funktsioonid (raamatukogude kujul) loetakse R-i töökeskkonda, (2) andmeid töödeldakse funktsioonide abil ja (3) tööproduktid eksporditakse/salvestatakse teistele programmidele kättesaadavasse vormi.  

* töökeskkond (workspace) - sisaldab üles laetud objekte

* keskkond (environment) - sisaldab nimega seotud objekte

* pakett e raamatukogu - sisaldab funktsioone, andmeid ja seletavaid faile

* funktsioon - R-i alamprogramm

* argument - funktsiooni tööd reguleeriv parameeter 

* objekt - funktsioon, andmestruktuur ja mida iganes saab töökeskkonda viia

* nimi - objekt seotakse nimega <- abil, et see keskkonnas nähtavaks/taaskasutatavaks muuta

**Andmetüübid:**

* character - tähemärgid

* numeric (double) - ratsionaalarvud

* integer - täisarvud

* factor - muutuja, millel on loetud hulk nimedega "tasemeid" (levels), kus iga tase on sisemiselt kodeeritud täisarvuga alates 1st. On olemas nii järjestatud kui järjestamata tasemetega faktorid. Näit "mees"-naine on tüüpiliselt järjestamata tasemed, aga vähe-keskmiselt-palju peaks olema järjestatud.

* logical - TRUE/FALSE. TRUE on sisemiselt kodeeritud kui 1 ja FALSE kui 0. 

**relatsioonilised operaatorid**

* >, >= (on suurem või võrdne), <, <=, 

* == (võrdub), 

* != (ei võrdu), 

* %in% (sisaldub), 

* & (and),

* | (or)

```{r}
1 == 2
1 != 2

1 %in% 1:5
1&4 %in% 1:5 #1 ja 4 sisalduvad vektoris c(1, 2, 3, 4, 5) --- TRUE
c(1, 8) %in% 1:5
1|8 %in% 1:5 #1 või 8 sisalduvad vektoris c(1, 2, 3, 4, 5) --- TRUE
6 %in% 1:5 #6 sisaldub vektoris c(1, 2, 3, 4, 5) --- see lause on FALSE
char.vector <- c("apple", "banana", "cantaloupe", "dragonfruit")
"apple" %in% char.vector
```


**andmeklassid:** (idee on andmed struktureerida hõlbustamaks edasisi tehteid nendega)

* vektor - 1D järjestatud sama tüüpi andmed 

* list - kokku kogutud, järjestatud ja nimetatud objektid (vektorid, andmeraamid, mudelid, teised listid jms)

* maatriks - 2D neljakandiline andmestruktuur, mis koosneb sama tüüpi andmetest 

* andmeraam (data frame, tibble) - 2D neljakandiline andmestruktuur, mis koosneb veeru kaupa kõrvuti asetatud ühepikkustest vektoritest (erinevad vektorid võivad sisaldada erinevaid tüüpi andmeid). Lähim asi nelinurksele tabelile (aga Exceli tabelis -- erinevalt R-st -- saab samasse veergu panna ka erinevat tüüpi andmeid).


Avades R Studio peaksite nägema tühja keskkonda (Enviroment tab, ülal paremas aknas). R-i tööpõhimõte on järgmine. 

(1) te laete võrgust alla ja installeerite oma kõvakettale vajalikud R-i alamprogrammid, mida kutsutakse pakettideks ehk raamatukogudeks. Paketid on funktsioonide (kuigi mitte ainult) kogud. Need funktsioonid ei ole aga veel R-s kasutamiseks kättesaadavad.  

(2) te loete R-i töökeskkonda (workspace) sisse vajalikud paketid (oma kõvakettalt) ja andmetabeli(d), mida soovite töödelda (oma kõvakettalt või otse võrgust), muutes need seega R-s kasutatavaks. Seda tuleb teha igal R-i sessioonil uuesti. Igat asja, mis on töökeskkonnas, kutsutakse objektiks. Objektid, mis on omistatud nimele, ilmuvad nähtavale Enviroment tab-i, koos oma struktuuri lühikirjeldsega.

(3) Te sisestate töökeskkonnas olevatesse funtksioonidesse andmed ja argumendid. Sageli teeb üks funktsioon ühte toimingut, mistõttu koosneb teie töövoog funktsioonide rakendamisest üksteise järel sellisel moel, et eelmise funktsiooni väljund on sisend järgmisele funktsioonile. 

(4) Te ekspordite/salvestate oma kõvakettale need objektid (tabelid, joonised), mida soovite tulevikus avada teiste programmidega. Samuti salvestate oma põhilise töötulemuse - R-i scripti (näit .Rmd või .R laiendiga failina).

Järgmise sessiooni saate alustada juba oma salvestatud koodi baasilt --- jooksutades algandmete peal olemasoleva koodi ning seejärel lisades uut koodi (andmetabeli ja raamatukogud tuleb iga sessiooni jaoks uuesti keskkonda sisse lugeda).


## Funktsioon

* Hea funktsioon teeb ühte asja. Näiteks funktsioon `t()` ( _t_ tähendab _transpose_) transponeerib maatriksi nii, et ridadest saavad veerud ja vastupidi, aga funktsioon `c()` ( _c_ tähendab _combine_ v _concatenate_ ) moodustab sisestatud objektidest vektori. 

* Funktsiooni nime taha käivad sulud. Ilma sulgudeta funktsiooni nime jooksutamine annab väljundina selle funktsiooni koodi.

* Enamustel funktsioonidel on argumendid, mis käivad sulgude sisse ja on üksteisest komadega eraldatud. Kasutaja saab argumentidele anda väärtused, mis määravad andmed, millel funktsioon töötab, ja selle, mida funktsioon nende andmetega täpselt teeb. Funktsiooni iga argument täpsustab funktsiooni jaoks, mida teha.

* Osadel argumentidel on vaikeväärtused, mida saab käsitsi muuta. Vaikeväärtused, nagu ka funktsiooni argumentide nimekirja ja kirjelduse, leiab `?funktsiooni_nimi` (ilma sulgudeta) abil. NB! Ära kasuta funktsioone, mille argumente sa ei tunne.

* Argumendid võivad olla kas kohustuslikud (ilma argumendi väärtust sisestamata funktsioon ei tööta), või mitte.  Näiteks funktsioon `plot(x, y, ...)` argumendid on objekt nimega x, mis annab x teljele plotitud andmete koordinaadid, objekt nimega y, mis annab sama y teljele, ning lisaargumendid, mis võivad sõltuda x-i ja või y-i vormist. x on kohustuslik argument, aga y ei ole tingimata vajalik (kas y on vajalik või mitte, sõltub sisestatud x-i struktuurist).

* Kui argumendi väärtus sisestatakse teksti kujul, siis enamasti jutumärkides. Jutumärgid muudavad R-i jaoks teksti tähemärkide jadaks e stringiks, mille sees R numbreid ei tõlgenda arvudena. 

* Argumendid on järjestatud ja neil on nimed. Nimi trumpab järjekorra üle selles mõttes, et me võime argumentide nimed funktsiooni kirjutada suvalises järjekorras ilma, et funktsiooni töö sellest muutuks. Samas, kui me sisestame funktsiooni argumendid ilma nimedeta, siis on argumentide järjekord tähtis, sest need seostatakse vaikimisi nimedega vastavalt oma järjekorranumbrile. Oletame, et meil on vektorid `kaal <- c(2.3, 4.3, 3)` ja `pikkus <- c(7, 5, 9)`. Me võime need funktsiooni sisestada nii: `plot(x = kaal, y = pikkus)`, `plot(y = pikkus, x = kaal)` ja `plot(kaal, pikkus)` teevad kõik identse scatterploti (aga `plot(pikkus, kaal)` ei tee).  

* Funktsiooni esimese argumendi saab enamasti sisestada ka alternatiivsel viisil, %>% pipe operaatori abil. Niimoodi jooksevad fun(arg1, arg2) ja arg1 %>% fun(arg2) koodid enamasti identselt. Kumba koodi eelistada on seega "vaid" koodi loetavuse küsimus.

**Ülesanne:** uuri välja, mida määravad järgneva funktsiooni argumendid. 

`plot(table(rpois(100, 5)), type = "h", col = "red", lwd = 10, main = "rpois(100, lambda = 5)")`

Pane tähele, et funktsiooni "plot" argumendid "table" ja "rpois" on ka ise funktsioonid, millel on kummagil oma argumendid. 

## Sama koodi saab kirjutada neljal erineval viisil

Idee on sooritada järjest operatsioone nii, et eelmise operatsiooni väljund (R-i objekt)  oleks sisendiks järgmisele operatsioonile (funktsioonile). See on lihtne  hargnemisteta analüüsiskeem.

Kui me muudame olemasolevat objekti, siis me kas jätame muudetud objektile vana objekti nime või me anname talle uue nime. 
Esimesel juhul läheb eelmine muutmata objekt töökeskkonnast kaduma, aga nimesid ei tule juurde ja säilib töövoo sujuvus. 
Teisel juhul jäävad analüüsi vaheobjektid meile alles ja nende juurde saab alati tagasi tulla. Aga samas tekib palju sarnaste nimedega objekte.

### Esimene võimalus - anname järjest tekkinud objektid samale nimele.
```{r}
a <- c(2, 3)
a <- sum(a)
a <- sqrt(a)
a <- round(a, 2)
a
```

### Teine võimalus - uued nimed.
Nii saab tekkinud objekte hiljem kasutada.
```{r}
a <- c(2, 3)
a1 <- sum(a)
a2 <- sqrt(a1)
a3 <- round(a2, 2)
a3
```

### Kolmas võimalus on lühem variant esimesest. 
Me nimelt ühendame etapid toru `%>%` kaudu. Toru operaator ei ole siiski baas R-is kohe kättesaadav, vaid tuleb laadida kas **magrittr** või **dplyr** paketist (viimatinimetatu laadib selle funktsiooni ka vaikimisi esimesena nimetatud raamatukogust).
Siin me võtame objekti "a" (nö. andmed), suuname selle funktsiooni `sum()`, võtame selle funktsiooni väljundi ja suuname selle omakorda funktsiooni `sqrt()`. 
Seejärel võtame selle funktsiooni outputi ja määrame selle nimele "result" (aga võime selle ka mõne teise nimega siduda). 
Kui mõni funktsioon võtab ainult ühe parameetri, mille me talle toru kaudu sisse sõõdame, siis pole selle funktsiooni taga isegi sulge vaja (R hea stiili juhised soovitavad siiski alati kasutada funktsiooni koos sulgudega). 

See on hea lühike ja inimloetav viis koodi kirjutada, mis on masina jaoks identne esimese koodiga.
```{r}
library(dplyr)
a <- c(2, 3)
result <- a %>% sum() %>% sqrt() %>% round(2)
result
```

### Neljas võimalus, klassikaline baas R lahendus:
```{r}
a <- c(2, 3)
result <- round(sqrt(sum(a)), 2)
result
```
Sellist koodi loetakse keskelt väljappoole ja kirjutatakse alates viimasest operatsioonist, mida soovitakse, et kood teeks. 
Masina jaoks pole vahet. 
Inimese jaoks on küll: 4. variant nõuab hästi pestud ajusid.

Koodi lühidus 4 --> 3 --> 1 --> 2 (pikem)
Lollikindlus  2 --> 1 --> 3 --> 4 (vähem lollikindel)
Loetavus 3 --> 2 --> 1 --> 4 (halvemini loetav)

See on teie otsustada, millist koodivormi te millal kasutate, aga te peaksite oskama lugeda neid kõiki.


## objekt {#obj}

R-i töökeskkonnas "workspace" asuvad **objektid**, millega me töötame. Igal objektil on nimi, mille abil saab selle objektiga opereerida (teda argumendina funktsioonidesse sisestada). 
Tüüpilised objektid on:

- Vektorid, maatriksid, listid ja andmeraamid.
- Statistiliste analüüside väljundid (mudeliobjektid, S3, S4 klass).
- Funktsioonid.

Funktsioon `ls()` annab objektide nimed teie workspace-s.

`rm(a)` eemaldab objekti nimega a töökeskkonnast.

Selleks, et salvestada töökeskkond faili, kasuta "Save" nuppu "Environment" akna servast või menüüst "Session" -> "Save Workspace As".

Projekti sulgemisel salvestab RStudio vaikimisi töökeskkonna. 
**Parema reprodutseeritavuse huvides pole siiski soovitav töökeskkonda peale töö lõppu projekti sulgemisel salvestada!**. 
Lülitame automaatse salvestamise välja:

- Selleks mine "Tools" > "Global Options" > kõige ülemine, "R General" menüüs vali "Save workspace to .RData on exit" > "Never" ever!
- Võta ära linnuke "Restore .RData to workspace at startup" eest.

Kui on mingid kaua aega võtvad kalkulatsioonid või allalaadimised, salvesta need eraldi .rds faili ja laadi koodis vastavalt vajadusele: `write_rds()`, `read_rds()`.



### Objekt ja nimi

Kui teil sünnib laps, annate talle nime.
R-s on vastupidi: nimele antakse objekt
```{r}
babe <- "beebi"
babe
```

Siin on kõigepealt nimi (babe), siis assigneerimise sümbol `<-` ja lõpuks objekt, mis on nimele antud (string "beebi"). 

NB! Stringid on jutumärkides, nimed mitte.
Nimi üksi evalueeritakse kui käsk: "print object". Antud juhul trükitakse konsooli string "beebi"

Nüüd muudame objekti nime taga:
```{r}
babe <- c("saatan", "inglike")
babe
```

Tulemuseks on sama nimi, mis tähistab nüüd midagi muud (vektorit, mis koosneb 2st stringist). Objekt "beebi" kaotas oma nime ja on nüüd workspacest kadunud. 
`class()` annab meile objekti klassi.
```{r}
class(babe)
```
 Antud juhul `r class(babe)`. 

> Ainult need objektid, mis on assigneeritud nimele, lähevad workspace ja on sellistena kasutatvad edasises analüüsis.

```{r}
apples <- 2
bananas <- 3
apples + bananas
```
Selle ekspressiooni tulemus trükitakse ainult R konsooli. Kuna teda ei määrata nimele, siis ei ilmu see ka workspace.


```{r}
a <- 2
b <- 3
a <- a + b
# objekti nimega 'a' struktuur
str(a)
```
Nüüd on nimega a seostatud uus objekt, mis sisaldab numbrit 5 (olles ühe elemendiga vektor). Ja nimega a eelnevalt seostatud objekt, mis koosnes numbrist 2, on workspacest lahkunud. 

#### Nimede vorm

+ Nimed algavad ingliskeelse tähemärgiga, mitte numbriga ega $€%&/?~ˇöõüä
+ Nimed ei sisalda tühikuid
+ Tühiku asemel kasuta alakriipsu: näiteks eriti_pikk_nimi
+ SUURED ja väiksed tähed on nimes erinevad
+ Nimed peaksid kirjeldama objekti, mis on sellele nimele assigneeritud ja nad võivad olla pikad sest TAB klahv annab auto-complete.
+ alt + - on otsetee `<-` jaoks 

## Andmete tüübid

+ numeric / integer 
+ logical -- 2 väärtust TRUE/FALSE
+ character
+ factor (ordered and unordered) - 2+ diskreetset väärtust, mis võivad olla järjestatud suuremast väiksemani (aga ei asu üksteisest võrdsel kaugusel). Faktoreid käsitleme põhjalikumalt hiljem.

Faktoritel on tasemed (level) ja sisemiselt on iga faktori tase tähistatud täisarvulise numbriga.  

Andmete tüüpe saab üksteiseks konverteerida `as.numeric()`, `as.character()`, `as.factor()`.

```{r}
a <- 5:10 
#vektor, mis koosneb 6st täisarvust 5st 10-ni
class(a)

a_char <- c("5", "6", "7") 
#jutumärgid tähistavad tähemärki, mitte arvu.
class(a_char)

a1 <- as.factor(a)
a1
a2 <- as.numeric(a1) 
#see ei tööta, sest faktori tasemed 
#rekodeeritakse sisemiselt numbritena alates 1st. 
a2
a3 <- as.numeric(as.character(a1)) 
#see töötab, taastab numbrid 5st 10-ni
#kõigepealt konverteerime faktori tasemed tähemärkideks 
#(ignoreerides sisemisi rekodeeringuid).
#Seejärel konverteerime tähemärgid numbriteks.
a3
```

## Objektide klassid
### Vektor

Vektor on rida kindlas järjekorras arve, tähemärkide stringe või TRUE/FALSE loogilisi väärtusi. 
Iga vektor ja maatriks (mis on 2D vektor) sisaldab ainult ühte tüüpi andmeid. 
Vektor on elementaarüksus, millega me teeme tehteid. 
Andmetabelis ripuvad kõrvuti ühepikad vektorid (üks vektor = üks tulp) ja R-le meeldib arvutada vektori kaupa vasakult paremale (mis tabelis on ülevalt alla sest vektori algus on üleval tabeli peas). 
Pikema kui üheelemendise vektori loomiseks kasuta funktsiooni `c()` -- combine

Loome numbrilise vektori ja vaatame ta struktuuri:
```{r}
minu_vektor <- c(1, 3, 4)
str(minu_vektor)
```

Loome vektori puuduva väärtusega, vaatame vektori klassi:
```{r}
minu_vektor <- c(1, NA, 4)
minu_vektor
class(minu_vektor)
```
Klass jääb _numeric_-uks.

Kui vektoris on segamini numbrid ja stringid, siis muudetakse numbrid ka stringideks:
```{r}
minu_vektor <- c(1, "2", 2, 4, "joe")
minu_vektor
class(minu_vektor)
```
Piisab ühest "tõrvatilgast meepotis", et teie vektor ei sisaldaks enam numbreid.

Eelnevast segavektorist on võimalik numbrid päästa kasutades käsku `as.numeric()`:
```{r}
as.numeric(minu_vektor)
```
Väärtus "joe" muudeti NA-ks, kuna seda ei olnud võimalik numbriks muuta.
Samuti peab olema tähelepanelik faktorite muutmisel numbriteks:
```{r}
minu_vektor <- factor(c(9, "12", 12, 1.4, "joe"))
minu_vektor
class(minu_vektor)
## Kui muudame faktori otse numbriks, saame faktori taseme numbri
as.numeric(minu_vektor)
```

Faktorite muutmisel numbriteks tuleb need kõigepealt stringideks muuta:
```{r}
as.numeric(as.character(minu_vektor))
```


Järgneva trikiga saab stringidest kätte numbrid: 
```{r}
minu_vektor <- c(1, "A2", "$2", "joe")
## parse_number() is imported from tidyverse 'readr' 
minu_vektor <- parse_number(minu_vektor) %>% as.vector()
str(minu_vektor)
```

R säilitab vektori algse järjekorra. 
Sageli on aga vaja tulemusi näiteks vaatamiseks ja presenteerimiseks sorteerida suuruse või tähestiku järjekorras:
```{r eval=FALSE}
## sorts vector in ascending order
sort(x, decreasing = FALSE, ...)
```

Vektori unikaalsed väärtused saab kätte käsuga `unique()`:
```{r}
## returns a vector or data frame, but with duplicate elements/rows removed
unique(c(1,1,1,2,2,2,2,2,3,3,4,5,5))
```


Uus vektor automaatselt: `seq()` ja `rep()`

seq annab kasvava või kahaneva rea. rep kordab väärtusi.

```{r}
seq(2, 3, by = 0.5)
seq(2, 3, length.out = 5)
rep(1:2, times = 3)
rep(1:2, each = 3)
rep(c("a", "b"), each = 3, times = 2)
```

#### Tehted arvuliste vektoritega

Vektoreid saab liita, lahutada, korrutada ja jagada.
```{r}
a <- c(1, 2, 3)
b <- 4
a + b
```
Kõik vektor a liikmed liideti arvuga 3 (kuna vektor b koosnes ühest liikmest, läks see kordusesse)

```{r}
a <- c(1, 2, 3)
b <- c(4, 5) 
a + b
```
Aga see töötab veateatega, sest vektorite pikkused ei ole üksteise kordajad
1 + 4; 2 + 5, 3 + 4

```{r}
a <- c(1, 2, 3, 4)
b <- c(5, 6) 
a + b
```
See töötab: 1 + 5; 2 + 6; 3 + 5; 4 + 6 

```{r}
a <- c(1, 2, 3, 4)
b <- c(5, 6, 7, 8) 
a + b
```
Samuti see (ühepikkused vektorid --- igat liiget kasutatakse üks kord)

```{r}
a <- c(TRUE, FALSE, TRUE)
sum(a)
mean(a)
```
Mis siin juhtus? R kodeerib sisemiselt TRUE kui 1 ja FALSE kui 0-i. summa 1 + 0 + 1 = 2. Mean seevastu võtab ühtede summa (TRUE elementide arvu) suhte vektori elementide arvust ja annab seega TRUE väärtuste suhtarvu. Seda loogiliste väärtuste omadust õpime varsti praktikas kasutama. 

### List

List on objektitüüp, kuhu saab koondada kõiki teisi objekte, kaasa arvatud listid. R-i jaoks on list lihtsalt vektor, mille elemendid ei pean olema sama andmetüüpi (nagu tavalistel nn lihtsatel vektoritel).  
Praktikas kasutatakse listi enamasti lihtsalt erinevate R-i objektide koos hoidmiseks ühes suuremas meta-objektis. List on nagu jõuluvana kingikott, kus kommid, sokipaarid ja muud kingid segamini kolisevad. Listidega töötamist vaatame lähemalt veidi hiljem.

Näiteks list, kus on 1 vektor nimega a, 1 tibble nimega b ja 1 list nimega c, mis omakorda sisaldab vektorit nimega d ja tibblet nimega e. Seega on meil tegu rekursiivse listiga. 
```{r}
# numeric vector a
a <- runif(5)
# data.frame
ab <- data.frame(a, b = rnorm(5))
# linear model
model <- lm(mpg ~ hp, data = mtcars)
# your grandma on bongos
grandma <- "your grandma on bongos"
# let's creat list
happy_list <- list(a, ab, model, grandma)
happy_list
```

Võtame listist välja elemndi "ab":
```{r}
happy_list$ab
```


### data frame ja tibble

Andmeraam on eriline list, mis koosneb ühepikkustest ja sama tüüpi vektoritest (listi iga element on vektor). Iga vektor on df-i veerg ja igas veerus on ainult ühte tüüpi andmed. Need vektorid ripuvad andmeraamis kõrvuti nagu tuulehaugid suitsuahjus, kusjuures vektori algus vastab tuulehaugi peale, mis on konksu otsas (konks vastab andmeraamis veeru nimele). Iga vektori nimi muutub sellises tabelis veeru nimeks. 

R-s on 2 andmeraami tüüpi: data frame ja tibble, mis on väga sarnased. 
Tibble on uuem, veidi kaunima väljatrükiga ja pisut mugavam kasutada.

> Erinevalt data frame-st saab tibblesse lisada ka list tulpasid, mis võimaldab sisuliselt suvalisi R objekte tibblesse paigutada. Põhimõtteliselt piisab ainult ühest andmestruktuurist -- tibble, et R-is töötada. Kõik, mis juhtub tibbles, jääb tibblesse. 

"Tidyverse" töötab tibblega veidi paremini kui data frame-ga, aga see vahe ei ole suur.

Siin on meil 3 vektorit: shop, apples ja oranges, millest me paneme kokku tibble nimega fruits
```{r}
## loome kolm vektorit
shop <- c("maxima", "tesco", "lidl")
apples <- c(1, 4, 43)
oranges <- c(2, 32, NA)
vabakava <- list(letters, runif(10), lm(mpg ~ cyl, mtcars))
## paneme need vektorid kokku tibble-sse
fruits <- tibble(shop, apples, oranges, vabakava)
fruits
```
Siin ta on, ilusti meie workspace-s. Pange tähele viimast tulpa "vabakava", mis sisaldab _character_ vectorit, numbrilist vektorit ja lineaarse mudeli objekti. 

Listi juba nii lihtsalt data.frame-i ei pane:
```{r}
dfs <- try(data.frame(shop, apples, oranges, vabakava))
dfs
```

### Matrix

Maatriks on 2-dimensionaalne vektor, sisaldab ainult ühte tüüpi andmeid -- numbrid, stringid, faktorid.

Tip: me saame sageli andmeraami otse maatriksina kasutada kui me viskame sealt välja mitte-numbrilised tulbad. Aga saame ka andmeraame konverteerida maatriksiks, ja tagasi.
```{r eval=FALSE}
fruits <- as.matrix(fruits)
class(fruits)
```

## Indekseerimine

Igale vektori, listi, andmeraami ja maatriksi elemendile vastab unikaalne postiindeks, mille abil saame just selle elemendi unikaalselt indentifitseerida, välja võtta ja töödelda.
Seega on indeksi mõte väga lühikese käsuga välja võtta R-i objektide üksikuid elemente. R-s algab indeksi numeratsioon 1-st (mitte 0-st, nagu näiteks Pythonis).

### Vektorid ja nende indeksid on ühedimensionaalsed

```{r}
my_vector <- 2:5 
my_vector
my_vector[1] #1. element ehk number 2
my_vector[c(1,3)] #1. ja 3. element 
my_vector[-1] #kõik elemendid, v.a. 1. element
my_vector[c(-1, -3)] #kõik elemendid, v.a. 1. ja 3. element 
my_vector[3:5] #elemendid 3, 4 ja 5 (element 5 on määramata, seega NA)
my_vector[-(3:length(my_vector))] #1. ja 2. element
```

### Andmeraamid ja maatriksid on kahedimensionaalsed, nagu ka nende indeksid

**2D indeksi kuju on [rea_indeks, veeru_indeks]**.

```{r eval=FALSE}
dat <- tibble(colA = c("a", "b", "c"), colB = c(1, 2, 3))
dat
# üks andmepunkt: 1. rida, 2. veerg
dat[1, 2]

# 1. rida, kõik veerud
dat[1, ]

# 2. veerg, kõik read
dat[, 2]

# kõik read peale 1.
dat[-1, ]

# viskab välja 2. veeru
dat[, -2]

# 2 andmepunkti: 2. rida, 1. ja 2. veerg
dat[2, 1:2]

# 2 andmepunkti: 2. rida, 3. ja 4. veerg
dat[2, c(1, 2)]

#viskab välja 1. ja 2. rea
dat[-c(1, 2), ]

#veerg nimega colB, output on erandina vektor!
dat$colB
```
Kui me indekseerimisega tibblest veeru ehk vektori välja võtame, on output class: tibble. Kui me teeme sama data frame-st, siis on output class: vector.

Nüüd veidi keerulisemad konstruktsioonid, mis võimaldavad tabeli ühe kindla veeru väärtusi välja tõmmata teise veeru väärtuste järgi filteerides. Püüdke sellest koodist aru saada, et te hiljem ära tunneksite, kui midagi sellist vastu tuleb. Õnneks ei ole teil endil vaja sellist koodi kirjutada, me õpetame teile varsti lihtsama filtri meetodi.
```{r}
dat <- tibble(colA = c("a", "b", "c"), colB = c(1, 2, 3))
dat$colB[dat$colA != "a" ] 
#jätab sisse kõik vektori colB väärtused, 
#kus samas tabeli reas olev colA väärtus ei 
#ole "a". output on vektor! 
dat$colA[dat$colB > 1] 
#jätab sisse kõik vektori colA väärtused, 
#kus samas tabeli reas olev colB väärtus >1. 
#output on vektor. 
```

### Listide indekseerimine

**Listi indekseerimisel kasutame kahte sorti nurksulge, "[ ]" ja "[[ ]]", mis töötavad erinevalt**.

Kui listi vaadata nagu objektide vanglat, siis kaksiksulgude `[[ ]]` abil on võimalik üksikuid objekte vanglast välja päästa nii, et taastub nende algne kuju ehk class.
Seevastu üksiksulud `[ ]` tekitavad uue listi, kus on säilinud osad algse listi elemendid, ehk uue vangla vähemate vangidega. 

> Kaksiksulud "[[ ]]" päästavad listist välja ühe elemendi ja taastavad selle algse class-i (data.frame, vektor, list jms). Üksiksulud "[ ]" võtavad algsest listist välja teie poolt valitud elemendid aga jätavad uue objekti ikka listi kujule.

```{r}
my_list <- list(a = tibble(colA = c("A", "B"), colB = c(1, 2)), b = c(1, NA, "s"))
## this list has two elements, a data frame called "a" and a character vector called "b".
str(my_list)
```

Tõmbame listist välja tibble:
```{r}
my_tibble <- my_list[[1]]
my_tibble
```
See ei ole enam list.

Nüüd võtame üksiksuluga listist välja 1. elemendi, mis on tibble, aga output ei ole mitte tibble, vaid ikka list. 
Seekord ühe elemendiga, mis on tibble.
```{r}
aa <- my_list[1]
str(aa)
```


```{r}
aa1 <- my_list$a[2,] #class is df
aa1
```

```{r}
aa3 <- my_list[[1]][1,]
aa3
```

Kõigepealt läksime kaksiksulgudega listi taseme võrra sisse ja võtsime välja objekti my_list 1. elemendi, tema algses tibble formaadis, (indeksi 1. dimensioon). Seejärel korjame sealt välja 1. rea, tibble formaati muutmata ja seega üksiksulgudes (indeksi 2. ja 3. dimensioon).

Pane tähele, et `[[ ]]` lubab ainult ühe elemendi korraga listist välja päästa.


# Lihtne töö Andmeraamidega


```{r}
count(iris, Species) #loeb üles, mitu korda igat näitu veerus Species esineb
summary(iris)
names(iris) #annab veerunimed
nrow(iris) #mitu rida?
ncol(iris) #mitu veergu?
arrange(iris, desc(Sepal.Length)) %>% head(3) 
#sorteerib tabeli veeru "Sepal.Length" väärtuste järgi 
#langevalt (default on tõusev sorteerimine). 
#Võib argumendina anda mitu veergu.
top_n(iris, 2, Sepal.Length) 
#saab 2 või rohkem rida, milles on kõige suuremad S.L. väärtused
top_n(iris, -2, Sepal.Length) #saab 2 rida, milles on kõige väiksemad väärtused 
```

Tibblega saab teha maatriksarvutusi, kui kasutada ainult arvudega ridu. 
`apply()` arvutab maatriksi rea (1) või veeru (2) kaupa, vastavalt funktsioonile, mille sa ette annad.
```{r}
colSums(fruits[ , 2:3])
rowSums(fruits[ , 2:3])
rowMeans(fruits[ , 2:3])
colMeans(fruits[ , 2:3])
fruits_subset <- fruits[ , 2:3]

# 1 tähendab, et arvuta sd rea kaupa
apply(fruits_subset, 1, sd)
# 2 tähendab, et arvuta sd veeru kaupa
apply(fruits_subset, 2, sd) 
```


Andmetabeli Summary saab mitmel viisil, skimr::skim() funktsioon on üks paremaid 
```{r}
skimr::skim(iris)
```

Lisame käsitsi tabelile rea:
```{r}
fruits <- add_row(fruits, 
                  shop = "konsum", 
                  apples = 132, 
                  oranges = -5, 
                  .before = 3)
fruits
```

Proovi ise:
```{r eval=FALSE}
add_column()
```

Eelnevaid verbe ei kasuta me just sageli, sest tavaliselt loeme andmed sisse väljaspoolt R-i. Aga väga kasulikud on järgmised käsud:

### Rekodeerime andmeraami väärtusi


```{r}
fruits$apples[fruits$apples==43] <- 333
fruits
fruits$shop[fruits$shop=="tesco"] <- "TESCO"
fruits
fruits$apples[fruits$apples>100] <- NA
fruits
```

Viskame välja duplikaatread, aga ainult need kus veerg nimega col1 sisaldab identseid väärtusi (mitmest identse väärtusega reast jääb alles ainult esimene)
```{r eval=FALSE}
distinct(dat, col1, .keep_all = TRUE)
# kõikide col vastu
distinct(dat) 
```

Rekodeerime `Inf` ja `NA` väärtused nulliks (mis küll tavaliselt on halb mõte):
```{r eval=FALSE}
# inf to 0
x[is.infinite(x)] <- 0
# NA to 0
x[is.na(x)] <- 0
```


### Ühendame kaks andmeraami rea kaupa 

Tabeli veergude arv ei muutu, ridade arv kasvab.
```{r}
dfs <- tibble(colA = c("a", "b", "c"), colB = c(1, 2, 3))
dfs1 <- tibble(colA = "d", colB =  4)
#id teeb veel ühe veeru, mis näitab, kummast algtabelist iga uue tabeli rida pärit on 
bind_rows(dfs, dfs1, .id = "id")
```

Vaata Environmentist need tabelid üle ja mõtle järgi, mis juhtus.

Kui `bind_rows()` miskipärast ei tööta, proovi `do.call(rbind, dfs)`, mis on väga sarnane.

NB! Alati kontrollige, et ühendatud tabel oleks selline, nagu te tahtsite!

Näiteks, võib-olla te tahtsite järgnevat tabelit saada, aga võib-olla ka mitte:
```{r}
df2 <- tibble(ColC = "d", ColD = 4)
## works by guessing your true intention
bind_rows(dfs1, df2)
```

### ühendame kaks andmeraami veeru kaupa

Meil on 2 verbi: bind_cols ja cbind, millest esimene on konservatiivsem. Proovige eelkõige bind_col-ga läbi saada, aga kui muidu ei saa, siis cbind ühendab vahest asju, mida bind_cols keeldub puutumast. NB! Alati kontrollige, et ühendatud tabel oleks selline, nagu te tahtsite!

```{r}
dfx <- tibble(colC = c(4, 5, 6))
bind_cols(dfs, dfx)
```

### andmeraamide ühendamine join()-ga

Kõigepealt 2 tabelit: df1 ja df2.

```{r}
df1 <- tribble(
  ~ Member,         ~ yr_of_birth,
  "John Lennon",    1940,
  "Paul McCartney", 1942
)

df1
```

```{r}
df2 <- tribble(
  ~ Member,            ~ instrument,    ~ yr_of_birth,
  "John Lennon",      "guitar",         1940,
  "Ringo Starr",      "drums",          1940,
  "George Harrisson", "guitar",         1942
)
df2
```

Ühendan 2 tabelit nii, et mõlema tabeli kõik read ilmuvad uude tabelisse.
```{r}
full_join(df1, df2)
```

Ühendan esimese tabeliga df2 nii, et ainult df1 read säilivad, aga df2-lt võetakse sisse veerud, mis df1-s puuduvad. See on hea join, kui on vaja algtabelile lisada infot teistest tabelitest.
```{r}
left_join(df1, df2)
```

Filtreerin välja need df1 read, millele vastab rida df2-s. 
```{r}
semi_join(df1, df2)
```

Filtreerin välja need df1 read, millele ei vasta rida df2-s.
```{r}
anti_join(df1, df2)
```


### Nii saab raamist kätte vektori, millega tehteid teha. 

Tibble jääb muidugi endisel kujul alles.
```{r}
ubinad <- fruits$apples
ubinad <- ubinad + 2
ubinad
## see on jälle vektor
str(ubinad)
```


## Andmeraamide salvestamine (eksport-import)

Andmeraami saame salvestada näiteks csv-na (comma separated file) oma kõvakettale, kasutame "tidyverse" analooge paketist "readr", mille nimed on baas R funktsioonidest eristatavad alakriipsu "_" kasutamisega. "readr" laaditakse automaatselt koos "tidyverse" laadimisega. 
```{r, eval=FALSE}
## loome uuesti fruits data tibble
shop <- c("maxima", "tesco", "lidl")
apples <- c(1, 4, 43)
oranges <- c(2, 32, NA)
fruits <- tibble(shop, apples, oranges, vabakava)
## kirjutame fruits tabeli csv faili fruits.csv kataloogi data 
write_csv(fruits, "data/fruits.csv")
```

Kuhu see fail läks? See läks meie projekti juurkataloogi kausta "data/", juurkataloogi asukoha oma arvuti kõvakettal leiame käsuga:
```{r}
getwd()
```

Andmete sisselugemine töökataloogist:
```{r eval=FALSE}
fruits <-  read_csv("data/fruits.csv")
```

Andmeraamide sisselugemiseks on kaks paralleelset süsteemi: baas-R-i read.table() ja selle mugavusfunktsioonid (read.csv(), read.csv2() jne) ning readr paketti, mis laaditakse koos tidyversiga, funktsioon read_delim() ja selle mugavusfunktsioonid (read_csv jne). Tavaliselt soovitame eelistada alakriipsuga variante (http://r4ds.had.co.nz/data-import.html). 

read_delim()-l ja selle poegade argument `col_types = cols(col_name_1 = col_double(), col_name_2 = col_date(format = ""))` võimaldab spetsifitseerida kindlatele veergudele, mis tüübiga need sisse loetakse. Töötab ka `cols_only(a = col_integer())`, samuti standardsed lühendid andmetüüpidele: `cols(a = "i", b = "d")`. Vaikimisi otsustab programm andmetüübi iga veeru esimese 1000 elemendi põhjal. Vahest tasub kõik veerud sisse lugeda character-idena, et oleks parem probleeme tuvastada: `df1 <- read_csv("my_data_frame_name.csv"), col_types = cols(.default = col_character()))`. .default	- kõik nimega veerud, mille kohta ei ole eksplitsiitselt teisiti õeldud, lähevad sisse lugemisel selle alla. .

Seda, milline sümbol kodeerib sisseloetavas failis koma ja milline on "grouping mark", mis eraldab tuhandeid, saab sisestada `locale = locale(decimal_mark = ",", grouping_mark = ".")` abil. Või näit: `locale("et", decimal_mark = ";")`. Vt ka https://cran.r-project.org/web/packages/readr/vignettes/locales.html.

https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes annab nimekirja riikide lokaalitähistest.

Argument `skip = n` jätab esimesed n rida sisse lugemata. Argument `comment = "#"` jätab sisse lugemata read, mis algavad #-ga.

Argument `col_names = FALSE` ei loe esimest rida sisse veerunimedena (see on vaikekäitumine) ja selle asemel nimetatakse veerud X1 ... Xn. `col_names = c("x", "y", "z"))` loeb tabeli sisse uute veerunimedega x, y ja z.

`na = "."` argument ütleb, et tabeli kirjed, mis on punktid, tuleb sisse lugeda NA-dena.

Kui teil on kataloogitäis faile (näit .csv lõpuga), mida soovite kõiki korraga sisse lugeda, siis tehke nii:
```{r eval=FALSE}
library(fs)
#järgnev loeb sisse iga faili eraldi kataloogist nimega data_dir
fs::dir_ls(data_dir, regexp = "\\.csv$") %>% map(read_csv)

#Kui meil on mitu faili samade tulbanimedega ja tahame
#need sisse lugeda ühte faili üksteise järel, siis
dir_ls(data_dir, regexp = "\\.csv$") %>% map_dfr(read_csv, .id = "source")
#.id on optsionaalne argument, mis lisab uude faili lisaveeru, 
#kus on unikaalsed viited igale algtabelile, et oleks näha, millisest
#tabelist iga uue tabeli rida pärit on.
```

MS exceli failist saab tabeleid importida "readxl" raamatukogu abil.
```{r, eval=FALSE}
library(readxl)
## kõigepealt vaatame kui palju sheete failis on
sheets <- excel_sheets("data/excelfile.xlsx")
## siis impordime näiteks esimese sheeti
dfs <- read_excel("data/excelfile.xlsx", sheet = sheets[1])
```

Excelist csv-na eksporditud failid tuleks sisse lugeda käsuga `read_csv2` või `read.csv2` (need on erinevad funktsioonid; read.csv2 loeb selle sisse data frame-na ja read_csv2 tibble-na).

R-i saab sisse lugeda palju erinevaid andmeformaate. 
Näiteks, installi RStudio addin: "Gotta read em all R", vaata eespool.
See läheb ülesse tab-i Addins. 
Sealt saab selle avada ja selle abil tabeleid oma workspace üles laadida. 

Alternatiiv: mine alla paremake Files tab-le, navigeeri sinna kuhu vaja ja kliki faili nimele, mida tahad R-i importida.

Mõlemal juhul ilmub alla konsooli (all vasakul) koodijupp, mille jooksutamine peaks asja ära tegema. Te võite tahta selle koodi kopeerida üles vasakusse aknasse kus teie ülejäänud kood tulevastele põlvedele säilub.

> Tüüpiliselt töötate R-s oma algse andmestikuga. Reprodutseeruvaks projektiks on vaja 2 asja: algandmeid ja koodi, millega neid manipuleerida. R ei muuda algandmeid, mille te näiteks csv-na sisse loete. 

Andmetabelite salvestamine töö vaheproduktidena ei ole sageli vajalik, sest te jooksutate iga kord, kui te oma projekti juurde naasete, kogu analüüsi uuesti kuni kohani, kuhu te pooleli jäite. See tagab, et teie kood töötab tervikuna. Erandiks on tabelid, mille arvutamine võtab palju aega.

Tibble konverteerimine data frame-ks ja tagasi tibbleks:
```{r}
class(fruits)
fruits <- as.data.frame(fruits)
class(fruits)
fruits <- as_tibble(fruits)
class(fruits)
```

## NA-d

```{r, dev = 'png'}
diabetes <- read.table(file = "data/diabetes.csv", sep = ";", dec = ",", header = TRUE)
str(diabetes)
aggr(diabetes, prop = FALSE, numbers = TRUE)
```
Siit on näha, et kui me viskame välja 2 tulpa ja seejärel kõik read, mis sisaldavad NA-sid, kaotame me umbes 20 rida 380-st, mis ei ole suur kaotus.

Kui palju ridu, milles on 0 NA-d? Mitu % kõikidest ridadest?
```{r}
nrows <- nrow(diabetes)
  ncomplete <- sum(complete.cases(diabetes))
  ncomplete #136
  ncomplete/nrows #34%
```

  
### Mitu NA-d on igas tulbas?

```{r}
diabetes %>% map_df(~sum(is.na(.))) %>% t()
```

väljund on uus tabel NA-de arvuga igale algse tabeli veerule

Eelnev ekspressioon töötab nii:
map_df() loeb kokku (summeerib) diabetes tabeli igale veerule, mitu elementi selles veerus andis ekspressioonile is.na() vastuseks TRUE. is.na() on funktsioon, mis annab väljundiks TRUE v FALSE, sõltuvalt vektori elemendi NA-staatusest. 

```{r}
is.na(c(NA, "3", "sd", "NA"))
```

Pane tähele, et string "NA" ei ole sama asi, mis loogiline konstant NA.

Ploti NAd punasega igale tabeli reale ja tulbale mida tumedam halli toon seda suurem number selle tulba kontekstis:
```{r, dev='png'}
matrixplot(diabetes) 
```


### Kuidas rekodeerida NA-d näiteks 0-ks:
```{r eval=FALSE}
dfs[is.na(dfs)] <- 0
dfs[is.na(dfs)] <- "other"
dfs[dfs == 0] <- NA # teeb vastupidi 0-d NA-deks
```

Pane tähele, et NA tähistamine ei käi character vectorina vaid dedikeeritud `is.na()` funktsiooniga.

coalesce teeb seda peenemalt.
kõigepealt kõik 
```{r message=FALSE}
x <- c(1:5, NA, NA, NA)
coalesce(x, 0L)
```

Nii saab 2 vektori põhjal kolmanda nii, et NA-d asendatakse vastava väärtusega:
```{r}
y <- c(1, 2, NA, NA, 5)
z <- c(NA, NA, 3, 4, 5)
coalesce(y, z)
```


`filter_all(weather, any_vars(is.na(.)))` näitab ridu, mis sisaldavad NA-sid

`filter_at(weather, vars(starts_with("wind")), all_vars(is.na(.)))` read, kus veerg, mis sisaldab wind, on NA.

### Rekodeerime NA-ks

```{r eval=FALSE}
na_if(x, y)
#x - vektor ehk tabeli veerg, mida modifitseerime
#y - väärtus, mida soovime NA-ga asendada

na_if(dfs, "") #teeb dfs tabelis tühjad lahtrid NA-deks
na_if(dfs, "other") #teeb lahtrid, kus on "other" NA-deks
na_if(dfs, 0) #teeb 0-d NA-deks. 
```


### drop_na() viskab tabelist välja NA-dega read

`drop_na(data, c(column1, column2))` - argument variable võimaldab visata välja read, mis on NA-d ainult kindlates veergudes (column1 ja column2 meie näites - aga ära unusta column1 asemele kirjutada oma veeru nime). Ära unusta ka kasutamast vektori vormi c(), et veerge määrata. column1:column4 vorm töötab samuti ja võtab NAd veergudest 1-4 (kui veeru nr 1 nimi on column1 jne).

### viska tabelist välja veerud, milles on liiga palju NA-sid

Meil on lai tabel sadade numbriliste veegudega. Neist paljud on NA-rikkad (andmevaesed) ja tuleks tabelist eemaldada. Aga kuidas seda teha?

Selleks (1) koostame vektori (vekt), milles on tabeli df-i iga numbrilise veeru NA-de suhtarv, (2) viskame sellest vektorist välja nende veergude nimed, milles on liiga palju NA-sid ja (3) subsetime df-i saadud vektori (vekt1) vastu. 

NB! vekt ja vekt1 on nn named vektorid, milles vektori iga element (NAde suhtarv mingis tabeli veerus) on seotud selle elemendi nimega, mis on identne selle veeru nimega tabelis df.

```{r eval=FALSE}
vekt <- sapply(df, function(x) mean(is.na(x))) 
#NA-de protsent igas veerus
vekt
vekt1 <- nad[nad < 0.8] 
#subsettisin vektori elemendid, mis on < 0.8 (NA-sid alla 80%). 216 tk.
#nad1 is a named vector
vekt1n <- names(vekt1) #vektor named vektori vekt1 nimedest
df_with_fewer_cols <- subset(df, select = vekt1n)
#subsetime (jätame alles) ainult need df-i veerud, 
#mille nimele vastab mõni vektori nad1n element
```


# itereerimine ja map() - sama operatsioon mitu korda

Järgnevad meetodid töötavad nii listidel, data frame-del kui vektoritel. Seda sellepärast, et formaalselt on list vektori tüüp (rekursiivne vektor), kuhu on võimalik elementidena panna mida iganes, k.a. teisi vektoreid. Selle tõttu enamus R-i funktsioone, mis töötavad lihtsate mitte-rekursiivsete vektoritega (ja df-dega), ei tööta listide peal. 

purr::map() perekonna funktsioonid töötavad nii lihtsate vektorite kui listide peal. Need funktsioonid kordavad kasutaja poolt ette antud funktsiooni igale vektori elemendile. map() vajab 2 argumenti: vektor ja funktsioon, mida selle vektori elementidele rakendada. map() võtab sisse listi (vektori, data frame) ja väljastab listi (vektori, data frame). Seega saab seda hästi pipe-s rakendada.

```{r}
list1 <- list(1, 2, 3, 4, 5)
list1 %>% map(log) %>% map(round)
```

Kui tahad, map() anda funktsiooni lisaargumentidega, siis need eraldatakse komadega `map(vector1, round, digits = 2)`.

Kui sa ei taha väljundina listi, vaid lihtsat numbrilist vektorit, siis kasuta `map_dbl()`. 

```{r}
list1 %>% map_dbl(log) %>% round()
```

map()-l on kokku 8 versiooni erinevate väljunditega.

* map() - list

* map_dbl() - floating point number vektor

* map_chr() - character vektor

* map_dfc() - data frame column binded

* map_dfr() - data frame row binded (lisab iga elemendi df-i reana)

* map_int() - integer vektor

* map_lgl() - logical vektor

* walk() - nähtamatu väljund (kasutatakse funktsioonide puhul, mis ei anna command line-le väljundit, nagu plot() või save file).

**Kuidas anda map-le funktsiooni asemel ette ekspressioon (näiteks max(df1$col1) - min(df1$col1))?**

ekspressiooni juhatab sisse ~ (tilde). 

Asenda ekspressioonis see, millega opereeritakse, .x -ga (~ max(.x) - min(.x)). 

pluck igast alam-listist mu ja sd ning kasuta neid, et genereerida 3 setti juhuslikke arve (millest igas on 5 juhuslikku arvu, mis on genereeritud vastavalt selle alam-listi mu-le ja sigmale).
```{r}
params <- list(
  "norm1" = list("mu" = 0, "sd" = 1),
  "norm2" = list("mu" = 1, "sd" = 1),
  "norm3" = list("mu" = 2, "scale" = 1)
)
params %>% map(~rnorm(5, mean = pluck(.x, 1), sd = pluck(.x, 2)))
```

`enframe()` konverteerib nimedega vektori df-ks, millel on 2 veergu (name, value). 

### map2()

itereerib üle kahe vektori - map2(v1, v2, fun).

**Tekspressioon map2()-le:**

algab tildega ~
esimese vektori elemendid on .x
teise vektori elemendid on .y

### pmap()

itereerib üle 3+ vektori. 

Name each vector in your list of vectors with the name of the argument that it should map to. pmap() will match names to arguments whenever you provide them. So this code, for example, will round each of the long numbers to a different number of digits.
```{r}
long_numbers <- list(pi, exp(1), sqrt(2))
digits <- list(2, 3, 4)
pmap(list(x = long_numbers, digits = digits), round)
```

pmap() ekspressioonide sisesed elemndid on ..1, ..2, ..3 jne, mitte .x ja .y nagu map2-l. 

NB! pmap-i saab sisetada data frame, mille peal see teeb kõike rea kaupa.

```{r}
parameters <- data.frame(
  n = c(1, 2, 3),
  min = c(0, 5, 10),
  max = c(1, 6, 11)
)
parameters %>% pmap(runif)
```

See töötab sest runif() võtab 3 argumenti ja df-l parameters on 3 veergu.

Järgmine funktsioon rakendub suvalisele df-le rea kaupa ja arvutab igale reale näit sd. Aga selleks transponeerime read veergudeks ja rakendame tavalist map()-i. 

```{r}
rmap <- function (.x, .f, ...) {
    if(is.null(dim(.x))) stop("dim(X) must have a positive length")
    .x <- t(.x) %>% as.data.frame(.,stringsAsFactors=F)
    purrr::map_dfr(.x=.x,.f=.f,...)
}
parameters %>% rmap(sd)
```

apply teeb sama lihtsamini.
```{r}
apply(parameters, 1, sd)
```

### invoke_map() 

itereerib üle funktsioonide vektori, millele järgneb argumentide vektor. 1. funktsioon  esimese argumendiga jne.
```{r}
functions <- list(rnorm, rlnorm, rcauchy)
n <- list(c(5, 2, 3), 2, 3)
invoke_map(functions, n)
```

anname sisse esimese argumendi (100) igasse funktsiooni
```{r}
functions <- list(rnorm, rlnorm, rcauchy)
n <- c(5, 2, 3)
invoke_map(functions, n, 100)
```

mitu argumenti igale funktsioonile:
```{r}
args <- list(norm = c(3, mean = 0, sd = 1), 
             lnorm = c(2, meanlog = 1, sdlog = 2),
             cauchy = c(1, location = 10, scale = 100))

invoke_map(functions, args)
```


#### map shortcuts

`pluck()` võtab listist välja elemendi (vektori, data frame jms) nii nagu see on (mitte listina).

```{r}
list1 <- list(
  numbers = 1:3,
  letters = c("a", "b", "c"),
  logicals = c(TRUE, FALSE)
)

pluck(list1, 1) # list1 %>% pluck(1)
pluck(list1, "numbers") # list1 %>% pluck("numbers")
```


Andes map()-le ette character stringi (elemendi nime), saame tagasi elemendi igast alam-listist, mille nimi vastab sellele stringile. See on shotcut pluck-ile.

```{r}
params <- list(
  "norm1" = list("mu" = 0, "sd" = 1),
  "norm2" = list("mu" = 1, "sd" = 1),
  "norm3" = list("mu" = 2, "scale" = 1)
)
map_dbl(params, "mu")
```

Sama teeb, kui map-le ette anda elemendi positsioon listis
```{r}
map_dbl(params, 1)
```

Nii saab kätte samad tulbad (vektorid) mitmest data frame-st (kui list sisaldab data frame-sid).

**veel mõned abifunktsioonid:**

lmap() works exclusively with functions that take lists
imap() applies a function to each element of a vector, and its index
map_at() and map_if() only map a function to specific elements of a list.

#### List column

Df-i veerg, mille andmetüüp on list. Näiteks mudeliobjektid, funktsioonid ja teised df-d võivad minna list columnisse!
List columnid on ise listid, mitte andmevektorid. 

      List veerud võimaldavad panna samasse tabelisse erinevaid asju - 
      andmeid, mudeleid, mudeli koefitsiente jms. 

nest() teeb uue df-i, kus on 1. veerg grupeeriva muutuja tasemetega, millele järgneb list column, mille iga element on tibble. Iga tibble sisaldab relevantset infot  grupeeriva muutuja vastava taseme kohta. 
```{r}
library(gapminder)
(nested_gapminder <- gapminder %>% group_by(country) %>% nest())
```

unnest() teeb algse df-i tagasi.

iga nested_gapminder$data element on ise df:
```{r}
nested_gapminder %>% 
  pluck("data") %>% 
  pluck(1) # %>% lm(lifeExp ~ year, data = .)
#fitime ühe mudeli 1. elemendile (1. riik)
```

fit a model to each tibble nested within nested_gapminder and then store those models as a list column
 
 fitime mudeli igale listi veerule (igale riigile). väljund on ilge list.
```{r}
model1 <- nested_gapminder %>%  
  pluck("data") %>%
  map(~ lm(lifeExp ~ year, data = .x))
```

arvutame mudelid igale riigile ja pistame väljundi (mudeliobjekti)  nested_gapminder uude list columnisse:
```{r}
models1 <- nested_gapminder %>% 
  mutate(models = map(data, ~ lm(lifeExp ~ year, data = .x)))
```


võtame välja mudeli koefitsiendi year ja paneme uude veergu nimega coefficient:
```{r}
models1 <-  models1 %>% mutate( coefficient = map_dbl(models, ~coef(.x) %>% pluck("year")) )
```

df-i veerg models on ühtlasi list, millele saame map_dbl() rakendada.


järgnevad 3 koodirida teevad sama asja - võtavad välja 1. mudeli:
```{r eval=FALSE}
models1 %>% 
  pluck("models") %>% 
  pluck(1)

models1[[1, 3]]

models1$models[[1]]
```


